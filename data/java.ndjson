{"id":101,"question":"What does the Java Memory Model guarantee with 'volatile' writes?","options":{"a":"Atomicity for all operations on the variable including ++","b":"Visibility and ordering (happens-before) from writer to subsequent readers","c":"Mutual exclusion for the variable","d":"Prevents false sharing"},"answer":"b","explanation":"volatile guarantees visibility + ordering (write → read happens-before); it does not provide atomic compound ops or mutual exclusion."}
{"id":102,"question":"Which statement about 'synchronized' is TRUE?","options":{"a":"It only provides visibility, not mutual exclusion","b":"It establishes happens-before from monitor exit to subsequent monitor enter on the same monitor","c":"It is faster than ReentrantLock in all cases","d":"It supports tryLock() with timeout"},"answer":"b","explanation":"Exiting a monitor happens-before a subsequent enter on the same monitor. It provides mutual exclusion; ReentrantLock adds features like tryLock()."}
{"id":103,"question":"Which operation on ConcurrentHashMap is atomic w.r.t. mapping presence?","options":{"a":"getOrDefault","b":"computeIfAbsent","c":"replaceAll","d":"forEach"},"answer":"b","explanation":"computeIfAbsent atomically checks presence and inserts the computed value for a key if absent."}
{"id":104,"question":"In Streams, which is a terminal operation?","options":{"a":"map","b":"peek","c":"collect","d":"filter"},"answer":"c","explanation":"collect is terminal; map, peek, filter are intermediate."}
{"id":105,"question":"Parallel streams: which is a common pitfall?","options":{"a":"Using stateless, associative reductions","b":"Using thread-safe collectors like toConcurrentMap","c":"Using non-associative accumulation (e.g., floating-point order sensitive)","d":"Using unordered sources"},"answer":"c","explanation":"Parallel reductions require associativity; non-associative ops can yield inconsistent results."}
{"id":106,"question":"CompletableFuture: which combines two independent futures and returns when BOTH complete?","options":{"a":"anyOf","b":"allOf","c":"applyToEither","d":"acceptEither"},"answer":"b","explanation":"allOf waits for all futures to complete; anyOf waits for any one."}
{"id":107,"question":"Which is TRUE about ForkJoinPool?","options":{"a":"Best for blocking I/O tasks","b":"Uses work-stealing among worker queues","c":"Requires explicit Thread creation","d":"Cannot run recursive tasks"},"answer":"b","explanation":"ForkJoinPool uses work-stealing; it’s designed for compute-bound, fine-grained tasks."}
{"id":108,"question":"Which GC is designed for low-pause times with region-based heap and is default in modern JDKs?","options":{"a":"Serial GC","b":"CMS","c":"G1 GC","d":"Epsilon"},"answer":"c","explanation":"G1 is region-based and default in recent JDK LTS versions (e.g., 17, 21), targeting predictable pauses."}
{"id":109,"question":"Which GC aims for ultra-low pauses with concurrent compaction and barrier-heavy design?","options":{"a":"Parallel GC","b":"ZGC","c":"Serial GC","d":"Shenandoah is the same as ZGC implementation"},"answer":"b","explanation":"ZGC is a concurrent, regioned, colored-pointers GC targeting very low pauses; Shenandoah is similar in goal but distinct."}
{"id":110,"question":"What does 'escape analysis' enable in HotSpot JIT?","options":{"a":"Turning objects into primitives","b":"Stack allocation and scalar replacement of non-escaping objects","c":"Ahead-of-time compilation only","d":"Disabling bounds checks"},"answer":"b","explanation":"If an object doesn’t escape a method/thread, JIT can allocate on stack or eliminate it via scalar replacement."}
{"id":111,"question":"Which is TRUE about the 'happens-before' relation?","options":{"a":"It is equivalent to wall-clock time","b":"Program order within a single thread contributes to happens-before","c":"It only arises from locks, not volatiles","d":"It guarantees fairness of scheduling"},"answer":"b","explanation":"Within a single thread, actions are ordered; synchronization constructs (locks, volatiles) also create happens-before edges."}
{"id":112,"question":"Which class provides lock downgrading (write→read) semantics?","options":{"a":"ReentrantLock","b":"Semaphore","c":"ReentrantReadWriteLock","d":"StampedLock only"},"answer":"c","explanation":"ReentrantReadWriteLock allows acquiring write then downgrading to read while holding locks properly."}
{"id":113,"question":"What’s a safe pattern to avoid ThreadLocal memory leaks in pools?","options":{"a":"Never remove values","b":"Use static ThreadLocal","c":"Call remove() in finally after use","d":"Use WeakReference yourself"},"answer":"c","explanation":"In pooled threads, always remove ThreadLocal values in finally-blocks to avoid retention."}
{"id":114,"question":"Which Map removes entries when keys are no longer strongly referenced?","options":{"a":"LinkedHashMap with accessOrder=true","b":"WeakHashMap","c":"IdentityHashMap","d":"ConcurrentSkipListMap"},"answer":"b","explanation":"WeakHashMap uses weak keys; entries are cleared when keys are GC-eligible."}
{"id":115,"question":"LinkedHashMap can be used to build an LRU cache by overriding which method?","options":{"a":"hashCode","b":"remove","c":"removeEldestEntry","d":"putIfAbsent"},"answer":"c","explanation":"Override removeEldestEntry and set accessOrder=true to evict least recently used entries."}
{"id":116,"question":"Which statement about 'record' in Java is TRUE?","options":{"a":"Records are mutable by default","b":"Records implicitly extend java.lang.Record and are final","c":"Records cannot define methods","d":"Records cannot implement interfaces"},"answer":"b","explanation":"Records are final, implicitly extend Record, and can define methods and implement interfaces; components are final."}
{"id":117,"question":"Sealed classes: which is valid?","options":{"a":"A sealed class must list permitted subclasses","b":"A sealed class cannot have final subclasses","c":"Permits must be at runtime only","d":"Sealed classes replace access modifiers"},"answer":"a","explanation":"Sealed classes enumerate permitted subclasses; subclasses must be sealed, non-sealed, or final."}
{"id":118,"question":"Pattern matching for 'instanceof' mainly helps with:","options":{"a":"Eliminating switch","b":"Reducing casts after the check","c":"Overloading resolution","d":"Operator overloading"},"answer":"b","explanation":"Pattern matching binds a variable when the instanceof test succeeds, avoiding explicit casts."}
{"id":119,"question":"JPMS modules vs classpath: what’s a key advantage of modules?","options":{"a":"Faster I/O","b":"Stronger encapsulation and reliable configuration","c":"Automatic serialization","d":"Guaranteed ABI stability across JDKs"},"answer":"b","explanation":"Modules provide explicit dependencies/exports and strong encapsulation beyond classpath rules."}
{"id":120,"question":"Which NIO feature supports asynchronous file I/O on supporting platforms?","options":{"a":"FileInputStream","b":"AsynchronousFileChannel","c":"BufferedReader","d":"RandomAccessFile only"},"answer":"b","explanation":"AsynchronousFileChannel provides async I/O operations in NIO.2."}
{"id":121,"question":"Which statement about Optional is BEST practice?","options":{"a":"Use Optional for fields to model absence","b":"Return Optional in public APIs, don’t use it for fields","c":"Serialize Optionals","d":"Use Optional for parameters"},"answer":"b","explanation":"Optional is for return types to signal possible absence; avoid fields/params for performance/clarity."}
{"id":122,"question":"Which is TRUE about virtual threads (Project Loom)?","options":{"a":"They are OS threads","b":"They are user-mode threads scheduled by the JVM, enabling massive concurrency","c":"They require synchronized for correctness","d":"They replace ExecutorService"},"answer":"b","explanation":"Virtual threads are lightweight, JVM-scheduled (user-mode) threads; they work with existing executors/APIs."}
{"id":123,"question":"CompletableFuture: which composes dependent async tasks sequentially?","options":{"a":"thenApply","b":"thenCompose","c":"thenAcceptBoth","d":"runAfterBoth"},"answer":"b","explanation":"thenCompose flattens and chains dependent futures (async → async)."}
{"id":124,"question":"Which annotation retention allows reflection at runtime?","options":{"a":"SOURCE","b":"CLASS","c":"RUNTIME","d":"BINARY"},"answer":"c","explanation":"RUNTIME retention keeps annotations available to reflection during execution."}
{"id":125,"question":"Which is TRUE about equals & hashCode?","options":{"a":"Only equals must be consistent with hashCode","b":"If equals is overridden, hashCode must usually be overridden","c":"hashCode may change within a HashSet safely","d":"Using mutable fields in hashCode is harmless"},"answer":"b","explanation":"Objects equal to each other must produce equal hash codes; mutability in keys can break hashed collections."}
{"id":126,"question":"What does VarHandle provide over sun.misc.Unsafe?","options":{"a":"Private, unsupported API","b":"A standardized, safe, reflective access to variables with memory-order ops","c":"No atomic operations","d":"Deprecated since Java 9"},"answer":"b","explanation":"VarHandle is the standard supported API for low-level atomic/memory-ordered operations."}
{"id":127,"question":"Which Collector is safe and efficient for parallel streams to build a Map?","options":{"a":"Collectors.toMap (with default merger)","b":"Collectors.toConcurrentMap (with merger)","c":"Collectors.groupingBy without supplier","d":"Collectors.toUnmodifiableMap"},"answer":"b","explanation":"toConcurrentMap with a merge function is designed for concurrent accumulation."}
{"id":128,"question":"Which tool/flag pair enables class data sharing to speed startup?","options":{"a":"-Xshare:off with CDS archive","b":"CDS/AppCDS with -Xshare:on","c":"-verbose:class only","d":"JFR automatically does this"},"answer":"b","explanation":"CDS/AppCDS share class metadata across JVMs using archives; enable with -Xshare:on."}
{"id":129,"question":"Which synchronization primitive best coordinates a variable number of phased tasks?","options":{"a":"CountDownLatch","b":"CyclicBarrier only","c":"Phaser","d":"Semaphore"},"answer":"c","explanation":"Phaser supports dynamic registration and multiple phases; more flexible than CountDownLatch/Barrier."}
{"id":130,"question":"StampedLock optimistic read: main caveat?","options":{"a":"It blocks writers","b":"Must validate the stamp before trusting the read","c":"It upgrades automatically to write lock","d":"It replaces volatile"},"answer":"b","explanation":"Optimistic reads must call validate(stamp) to ensure no write occurred; otherwise retry."}
{"id":131,"question":"What is the main purpose of an API Gateway in microservices?","options":{"a":"Database normalization","b":"Centralized routing, security, and aggregation","c":"Managing CI/CD pipelines","d":"Scaling the database"},"answer":"b","explanation":"An API Gateway acts as a single entry point to route requests, handle authentication, rate limiting, and sometimes aggregate responses from multiple services."}
{"id":132,"question":"Why do microservices often use asynchronous communication?","options":{"a":"It ensures immediate consistency","b":"It reduces coupling and improves scalability","c":"It eliminates the need for APIs","d":"It guarantees no data loss"},"answer":"b","explanation":"Asynchronous communication (via Kafka, RabbitMQ, etc.) allows services to remain loosely coupled and scale independently without blocking requests."}
{"id":133,"question":"In microservices, what problem does service discovery solve?","options":{"a":"Caching frequently used data","b":"Finding network locations of running service instances","c":"Encrypting service traffic","d":"Deploying containers automatically"},"answer":"b","explanation":"Service discovery dynamically tracks and provides endpoints for service instances, as IP/port addresses may change frequently in cloud or containerized environments."}
{"id":134,"question":"Which pattern is used to handle failures gracefully in microservices?","options":{"a":"Singleton","b":"Circuit Breaker","c":"Observer","d":"Decorator"},"answer":"b","explanation":"The Circuit Breaker pattern prevents cascading failures by stopping requests to a failing service and allowing it to recover."}
{"id":135,"question":"Why is database-per-service recommended in microservices?","options":{"a":"It ensures every service has the same schema","b":"It enforces loose coupling and independent scaling","c":"It makes joins easier across services","d":"It allows all services to share a single cache"},"answer":"b","explanation":"A database-per-service ensures data ownership, independence, and prevents tight coupling between services."}
{"id":136,"question":"What’s the main drawback of distributed transactions in microservices?","options":{"a":"They are too fast","b":"They increase system coupling and complexity","c":"They eliminate consistency issues","d":"They prevent scaling"},"answer":"b","explanation":"Distributed transactions (like 2PC) add latency, complexity, and tight coupling, which goes against microservice principles."}
{"id":137,"question":"Which principle does the Saga pattern enforce in microservices?","options":{"a":"Immediate consistency","b":"Eventual consistency via local transactions","c":"Centralized transaction manager","d":"Database-per-cluster"},"answer":"b","explanation":"Saga breaks large distributed transactions into smaller local transactions coordinated via events, ensuring eventual consistency."}
{"id":138,"question":"What role does observability play in microservices?","options":{"a":"It manages scaling policies","b":"It provides visibility with logs, metrics, and traces","c":"It stores application secrets","d":"It ensures only stateless services run"},"answer":"b","explanation":"Observability (via tools like ELK, Prometheus, Grafana, Zipkin) helps monitor system health with logs, metrics, and distributed traces."}
{"id":139,"question":"Why is containerization (e.g., Docker) commonly used for microservices?","options":{"a":"It enforces strong typing in services","b":"It ensures consistent environments and portability","c":"It eliminates the need for APIs","d":"It avoids CI/CD pipelines"},"answer":"b","explanation":"Containers package microservices with dependencies, ensuring consistency across development, test, and production environments."}
{"id":140,"question":"What is the main challenge with inter-service communication in microservices?","options":{"a":"It makes debugging easier","b":"It introduces network latency and reliability concerns","c":"It prevents scaling","d":"It simplifies data consistency"},"answer":"b","explanation":"Since microservices communicate over the network, latency, retries, and reliability must be carefully handled with patterns like retries, timeouts, and circuit breakers."}
{"id":141,"question":"Explain the difference between == and .equals() in Java.","options":{"a":"== compares values, .equals() compares memory references","b":"== compares references, .equals() compares content","c":"Both compare only primitive values","d":"Both compare only object identity"},"answer":"b","explanation":"== checks reference equality (whether two references point to the same object), while .equals() checks logical equality, usually content."}
{"id":142,"question":"Why is String immutable in Java?","options":{"a":"To save memory","b":"To improve performance","c":"To ensure security, caching, and thread-safety","d":"Because JVM does not allow mutable objects"},"answer":"c","explanation":"String immutability ensures cached values (like hashCode), security in class loading, and thread-safety since multiple threads can share Strings safely."}
{"id":143,"question":"What is the difference between HashMap and ConcurrentHashMap?","options":{"a":"HashMap is synchronized, ConcurrentHashMap is not","b":"HashMap allows null keys/values, ConcurrentHashMap restricts nulls and supports concurrency","c":"Both are identical except for hashing algorithm","d":"ConcurrentHashMap uses linked lists only"},"answer":"b","explanation":"HashMap is not thread-safe and allows one null key, while ConcurrentHashMap is thread-safe and disallows null keys/values."}
{"id":144,"question":"Explain the concept of fail-fast vs fail-safe iterators.","options":{"a":"Fail-fast throws ConcurrentModificationException, fail-safe does not","b":"Fail-fast is thread-safe, fail-safe is not","c":"Fail-safe uses locks, fail-fast uses copies","d":"Fail-fast iterates slower"},"answer":"a","explanation":"Fail-fast iterators throw ConcurrentModificationException when collection is modified during iteration, while fail-safe iterators iterate over a copy and avoid exceptions."}
{"id":145,"question":"What is the significance of hashCode() and equals() method?","options":{"a":"They are used for JVM memory allocation","b":"They define object equality and affect collections like HashMap","c":"They are only used for Strings","d":"They are optional and unused in Java"},"answer":"b","explanation":"hashCode() and equals() determine how objects are compared and stored in hash-based collections like HashMap and HashSet."}
{"id":146,"question":"How does ArrayList work internally?","options":{"a":"Uses dynamic arrays that resize as needed","b":"Uses linked lists","c":"Uses hash tables","d":"Uses a tree structure"},"answer":"a","explanation":"ArrayList uses a resizable array; when capacity is exceeded, it creates a new array with larger size and copies elements over."}
{"id":147,"question":"What is the difference between ArrayList and LinkedList?","options":{"a":"ArrayList uses dynamic arrays, LinkedList uses doubly linked nodes","b":"ArrayList is faster for insertions, LinkedList is faster for random access","c":"Both use linked structures","d":"Both have identical performance"},"answer":"a","explanation":"ArrayList uses a resizable array for fast random access; LinkedList uses a doubly linked list, making insertions/deletions efficient but random access slower."}
{"id":148,"question":"How does Java handle memory management?","options":{"a":"Developers must manually allocate and free memory","b":"Uses automatic Garbage Collection for heap memory","c":"Memory is fixed and cannot be freed","d":"Only stack memory is managed"},"answer":"b","explanation":"Java handles memory automatically using Garbage Collection, reclaiming unused objects in heap memory."}
{"id":149,"question":"What is the role of the final keyword?","options":{"a":"Prevents class inheritance, method overriding, or reassignment of variables","b":"Used only for constants","c":"Marks a class as abstract","d":"Used only for memory optimization"},"answer":"a","explanation":"The final keyword prevents changes: final classes cannot be extended, final methods cannot be overridden, and final variables cannot be reassigned."}
{"id":150,"question":"How does Garbage Collection work in Java?","options":{"a":"Manually triggered by the programmer","b":"Automatically reclaims memory for unreachable objects","c":"Deletes stack frames","d":"Runs only when JVM shuts down"},"answer":"b","explanation":"Garbage Collection automatically reclaims memory from objects no longer referenced, preventing memory leaks."}
{"id":151,"question":"What is a WeakHashMap?","options":{"a":"A HashMap with weak thread-safety","b":"A map where keys are held with weak references and can be garbage collected","c":"A slower version of HashMap","d":"A map with only string keys"},"answer":"b","explanation":"WeakHashMap holds keys with weak references, allowing them to be garbage collected when no longer in ordinary use."}
{"id":152,"question":"How is synchronization achieved in Java?","options":{"a":"Using synchronized keyword, Locks, or concurrent utilities","b":"By using volatile variables","c":"By using static methods","d":"By avoiding threads"},"answer":"a","explanation":"Synchronization in Java is achieved using synchronized blocks/methods, explicit locks (ReentrantLock), and high-level concurrency utilities."}
{"id":153,"question":"What are the different thread states?","options":{"a":"Running, Waiting, Paused, Killed","b":"New, Runnable, Blocked, Waiting, Timed Waiting, Terminated","c":"Start, Run, Sleep, End","d":"Idle, Active, Paused"},"answer":"b","explanation":"Java threads can be in states: New, Runnable, Blocked, Waiting, Timed Waiting, or Terminated."}
{"id":154,"question":"What is the difference between Runnable and Callable?","options":{"a":"Runnable returns a result, Callable does not","b":"Callable returns a result and can throw exceptions, Runnable does not","c":"Both are identical","d":"Callable is used only for threads"},"answer":"b","explanation":"Runnable cannot return results or throw checked exceptions; Callable can return values and throw exceptions."}
{"id":155,"question":"What is thread starvation?","options":{"a":"When a thread consumes too many resources","b":"When a thread is blocked indefinitely due to lack of CPU access","c":"When thread priority is too high","d":"When threads are paused by the GC"},"answer":"b","explanation":"Thread starvation occurs when low-priority threads never get CPU time due to higher-priority threads dominating resources."}
{"id":156,"question":"What is the difference between wait(), sleep(), and yield()?","options":{"a":"wait() releases lock, sleep() pauses without releasing, yield() hints scheduler","b":"All three pause a thread the same way","c":"sleep() releases lock, wait() does not","d":"yield() is the same as wait()"},"answer":"a","explanation":"wait() releases monitor lock and waits, sleep() pauses but keeps lock, yield() suggests the scheduler to give other threads CPU."}
{"id":157,"question":"How does the volatile keyword work?","options":{"a":"Provides full synchronization","b":"Ensures visibility of changes across threads","c":"Prevents thread creation","d":"Locks an object"},"answer":"b","explanation":"volatile ensures that reads/writes to a variable are always done from main memory, guaranteeing visibility across threads."}
{"id":158,"question":"What is a race condition? How to prevent it?","options":{"a":"When multiple threads access shared data incorrectly; prevent using synchronization","b":"When threads finish tasks too quickly","c":"When two classes have same name","d":"When GC deletes objects prematurely"},"answer":"a","explanation":"A race condition occurs when multiple threads modify shared data simultaneously. It is prevented using synchronization, locks, or atomic classes."}
{"id":159,"question":"Explain ReentrantLock vs synchronized block.","options":{"a":"Both are identical","b":"ReentrantLock provides more features like tryLock() and fairness, unlike synchronized","c":"synchronized is faster and always preferred","d":"ReentrantLock cannot be reentrant"},"answer":"b","explanation":"ReentrantLock provides advanced features like fairness, tryLock, and interruptibility, whereas synchronized is simpler and built-in."}
{"id":160,"question":"What is thread pooling and how is it implemented?","options":{"a":"Creating new thread for each task","b":"Using Executor framework to reuse a fixed number of threads","c":"Allocating all CPU cores to one thread","d":"Using synchronized blocks only"},"answer":"b","explanation":"Thread pooling uses the Executor framework (like ThreadPoolExecutor) to reuse threads for multiple tasks, improving efficiency."}
{"id":161,"question":"What is the Fork/Join framework?","options":{"a":"A scheduling algorithm","b":"A framework to parallelize tasks by splitting into subtasks and combining results","c":"A networking API","d":"A way to handle exceptions"},"answer":"b","explanation":"The Fork/Join framework parallelizes large tasks into smaller ones (fork) and merges results (join) efficiently."}
{"id":162,"question":"Explain Stream API with examples.","options":{"a":"A library for handling files","b":"A library for functional-style operations on collections","c":"A networking API","d":"A concurrency framework"},"answer":"b","explanation":"The Stream API allows functional-style operations like map, filter, reduce on collections, enabling concise and parallelizable code."}
{"id":163,"question":"Difference between map() and flatMap() in Streams?","options":{"a":"map flattens results, flatMap does not","b":"map transforms elements, flatMap transforms and flattens nested structures","c":"Both are identical","d":"map is for lists, flatMap is for arrays"},"answer":"b","explanation":"map applies a function to each element and returns a Stream; flatMap applies a function and flattens nested results into a single Stream."}
{"id":164,"question":"What are functional interfaces?","options":{"a":"Interfaces with only abstract methods","b":"Interfaces with exactly one abstract method","c":"Interfaces with default methods only","d":"Interfaces used only for concurrency"},"answer":"b","explanation":"A functional interface has exactly one abstract method, making it suitable for lambda expressions and method references."}
{"id":165,"question":"What is the difference between Optional.of() and Optional.ofNullable()?","options":{"a":"Both throw NullPointerException for null values","b":"Optional.of() throws if null, Optional.ofNullable() allows null","c":"Optional.ofNullable() throws if null, Optional.of() allows null","d":"Both behave the same"},"answer":"b","explanation":"Optional.of() throws NullPointerException if the value is null, while Optional.ofNullable() safely creates an empty Optional for null values."}
{"id":166,"question":"What is method reference in Java?","options":{"a":"A reference to methods for debugging","b":"A shorthand for lambda expressions referring to methods","c":"A reflection-based call","d":"A special keyword in Java"},"answer":"b","explanation":"Method references (:: operator) are shorthand for lambdas that call existing methods, e.g., list.forEach(System.out::println)."}
{"id":167,"question":"How does Collectors.groupingBy() work?","options":{"a":"Groups elements into lists based on a classifier function","b":"Sorts elements","c":"Removes duplicates","d":"Splits a Stream into parallel chunks"},"answer":"a","explanation":"Collectors.groupingBy() groups stream elements into a Map by applying a classifier function, e.g., grouping employees by department."}
{"id":168,"question":"What is the default method in interfaces?","options":{"a":"A method with no return type","b":"A method with default keyword providing body in interface","c":"A method that must be overridden","d":"A static method in interface"},"answer":"b","explanation":"Default methods in interfaces use the default keyword and provide implementation, enabling backward compatibility."}
{"id":169,"question":"What are sealed classes in Java?","options":{"a":"Classes that cannot be extended","b":"Classes that restrict which classes can extend them","c":"Classes marked with final","d":"Classes used only in records"},"answer":"b","explanation":"Sealed classes (introduced in Java 17) restrict which classes or interfaces can extend or implement them using permits keyword."}
{"id":170,"question":"What is a record class in Java?","options":{"a":"A special class for logging","b":"A compact class for immutable data with automatic constructor, equals, hashCode, and toString","c":"A replacement for enums","d":"A database class"},"answer":"b","explanation":"Records are immutable data carriers introduced in Java 14+, auto-generating constructor, equals, hashCode, and toString."}
{"id":171,"question":"Difference between checked and unchecked exceptions.","options":{"a":"Checked are subclasses of RuntimeException, unchecked are not","b":"Checked must be declared/handled, unchecked do not require it","c":"Unchecked must be declared, checked do not","d":"Both are same"},"answer":"b","explanation":"Checked exceptions must be declared or handled; unchecked exceptions (RuntimeException) are not required to be declared."}
{"id":172,"question":"How is custom exception handling used in real-world applications?","options":{"a":"By ignoring exceptions","b":"By creating user-defined exception classes extending Exception or RuntimeException","c":"By always using try-finally only","d":"By suppressing errors"},"answer":"b","explanation":"Custom exceptions are created by extending Exception/RuntimeException to represent domain-specific errors for better clarity and handling."}
{"id":173,"question":"What is the diamond problem in Java?","options":{"a":"Ambiguity caused by multiple inheritance of classes","b":"Confusion in enum usage","c":"Hash collision issue","d":"Reflection ambiguity"},"answer":"a","explanation":"Diamond problem arises with multiple inheritance, but Java avoids it with single class inheritance and resolves with interface default methods."}
{"id":174,"question":"How does autoboxing/unboxing work?","options":{"a":"Converts primitives to wrappers and vice versa automatically","b":"Converts Strings to primitives","c":"Manual casting of objects","d":"Reflection-based type conversion"},"answer":"a","explanation":"Autoboxing automatically converts primitives to wrapper objects, and unboxing converts wrappers back to primitives."}
{"id":175,"question":"Explain Enum in Java.","options":{"a":"A collection class","b":"A special type for fixed constants with type safety","c":"A wrapper class","d":"A primitive type"},"answer":"b","explanation":"Enums represent fixed sets of constants with type safety and can include fields, methods, and constructors."}
{"id":176,"question":"When to use TreeMap vs HashMap?","options":{"a":"TreeMap is unordered, HashMap is ordered","b":"TreeMap maintains sorted keys, HashMap provides constant-time lookup","c":"Both are identical","d":"HashMap is thread-safe, TreeMap is not"},"answer":"b","explanation":"TreeMap maintains natural or custom ordering of keys (O(log n)), while HashMap gives constant-time lookup (O(1))."}
{"id":177,"question":"Why should hashCode() be consistent with equals()?","options":{"a":"To allow garbage collection","b":"To ensure objects behave correctly in hash-based collections","c":"To improve JVM performance","d":"To support reflection"},"answer":"b","explanation":"If equals() returns true, hashCode() must return same value; otherwise collections like HashMap/HashSet will misbehave."}
{"id":178,"question":"How to make an object immutable?","options":{"a":"By marking class abstract","b":"By making fields final, private, no setters, and defensive copying","c":"By synchronizing methods","d":"By using static fields"},"answer":"b","explanation":"Immutable objects have final private fields, no setters, constructors set values, and defensive copies for mutable fields."}
{"id":179,"question":"What is the use of transient keyword?","options":{"a":"Marks a variable as constant","b":"Prevents a field from being serialized","c":"Prevents inheritance","d":"Used only in enums"},"answer":"b","explanation":"The transient keyword prevents a field from being serialized, useful for sensitive or derived data."}
{"id":180,"question":"What is reflection in Java?","options":{"a":"Ability to create threads","b":"Ability to inspect and manipulate classes, methods, fields at runtime","c":"Garbage Collection process","d":"Default method in interfaces"},"answer":"b","explanation":"Reflection allows inspection and modification of class members at runtime using java.lang.reflect API."}
{"id":181,"question":"What is the difference between static and instance initialization block?","options":{"a":"Static runs once per class load, instance runs per object creation","b":"Both run per object creation","c":"Static runs per object, instance runs once per class","d":"No difference"},"answer":"a","explanation":"Static initialization block runs once when class is loaded; instance initialization block runs every time an object is created."}
{"id":182,"question":"Difference between shallow copy and deep copy.","options":{"a":"Shallow copies references, deep copies actual objects","b":"Shallow copy clones everything deeply","c":"Deep copy is faster","d":"Both are identical"},"answer":"a","explanation":"Shallow copy copies object references without new objects, while deep copy creates independent copies of nested objects."}
{"id":183,"question":"What is the use of System.identityHashCode()?","options":{"a":"Returns JVM memory address","b":"Returns default hash code regardless of overridden hashCode()","c":"Generates unique id for every object","d":"Stores hash in cache"},"answer":"b","explanation":"System.identityHashCode() returns the default hash code of an object even if its hashCode() is overridden."}
{"id":184,"question":"Explain CompletableFuture with example.","options":{"a":"Used for handling IO only","b":"Supports async programming with callbacks and chaining","c":"A replacement for ExecutorService","d":"A type of Stream"},"answer":"b","explanation":"CompletableFuture allows async tasks with methods like thenApply, thenRun, and can combine multiple futures."}
{"id":185,"question":"How do you implement a singleton pattern?","options":{"a":"By using abstract classes","b":"By making constructor private and providing static getInstance()","c":"By using final keyword","d":"By using multiple constructors"},"answer":"b","explanation":"Singleton ensures one instance by making constructor private and exposing a static method to get the instance."}
{"id":186,"question":"What are some ways to break a singleton?","options":{"a":"Using reflection, cloning, or serialization","b":"By using multiple threads","c":"By using default methods","d":"By using abstract classes"},"answer":"a","explanation":"Singletons can be broken by reflection, cloning, or serialization unless additional safeguards are applied."}
{"id":187,"question":"What is double-checked locking?","options":{"a":"A thread pool technique","b":"A concurrency pattern for lazy initialization with minimal locking","c":"A method of exception handling","d":"A GC optimization"},"answer":"b","explanation":"Double-checked locking reduces overhead by checking instance twice—once without locking and again inside synchronized block."}
{"id":188,"question":"What are phantom references?","options":{"a":"References that prevent GC","b":"References that are enqueued after object finalization","c":"References that act like weak references","d":"References to static fields"},"answer":"b","explanation":"PhantomReference objects are enqueued after the referent is finalized but before memory is reclaimed."}
{"id":189,"question":"Why is clone() considered bad practice?","options":{"a":"It is slow and doesn’t work for primitives","b":"It causes shallow copies, breaks encapsulation, and is error-prone","c":"It cannot be overridden","d":"It always throws exceptions"},"answer":"b","explanation":"clone() is discouraged because it causes shallow copies, violates encapsulation, and is complex to implement correctly."}
{"id":190,"question":"How would you design your own custom collection?","options":{"a":"By extending Collection or Map interfaces and implementing required methods","b":"By using only arrays","c":"By overriding hashCode","d":"By extending Object"},"answer":"a","explanation":"Custom collections can be built by implementing Collection/Map interfaces and defining behavior for required methods."}
{"id":191,"question":"Explain method overloading vs overriding.","options":{"a":"Overloading changes method behavior in subclass, overriding changes parameters","b":"Overloading is compile-time polymorphism, overriding is runtime polymorphism","c":"Both are identical","d":"Overriding is compile-time only"},"answer":"b","explanation":"Overloading defines multiple methods with same name but different signatures; overriding redefines method behavior in subclass."}
{"id":192,"question":"Explain covariant return types.","options":{"a":"Return type in overriding method can be a subclass of original return type","b":"Return type must always match exactly","c":"Return type must be Object","d":"Return type must be primitive"},"answer":"a","explanation":"Covariant return types allow overriding methods to return a more specific type than the method they override."}
{"id":193,"question":"How does Java handle pass-by-value or reference?","options":{"a":"Java is pass-by-reference","b":"Java is pass-by-value, but object references are passed by value","c":"Java uses both pass-by-value and reference","d":"Java is pass-by-pointer"},"answer":"b","explanation":"Java is strictly pass-by-value. For objects, the reference is passed by value, so changes to the object are reflected, but reassignments don’t affect the original reference."}
{"id":194,"question":"Can we override private/static/final methods?","options":{"a":"Yes, all can be overridden","b":"Private and static cannot be overridden, final methods cannot be overridden","c":"Static methods can be overridden","d":"Private methods can be overridden"},"answer":"b","explanation":"Private methods are not inherited, static methods are hidden not overridden, and final methods cannot be overridden."}
{"id":195,"question":"When would you use an abstract class over interface?","options":{"a":"When you want multiple inheritance","b":"When you need shared code with state and partial implementation","c":"When you need constants only","d":"When you need runtime polymorphism only"},"answer":"b","explanation":"Abstract classes allow fields, constructors, and partial implementations, making them useful when shared state or behavior is needed."}
{"id":196,"question":"What is java.lang.instrument used for?","options":{"a":"For database connections","b":"For bytecode instrumentation and profiling agents","c":"For GUI development","d":"For networking"},"answer":"b","explanation":"The java.lang.instrument package provides services that allow Java agents to instrument program bytecode at runtime."}
{"id":197,"question":"What is Metaspace in Java?","options":{"a":"Heap memory for objects","b":"Non-heap memory for class metadata introduced in Java 8","c":"Thread stack memory","d":"Off-heap storage for arrays"},"answer":"b","explanation":"Metaspace is the memory region in native memory where JVM stores class metadata, replacing PermGen from Java 8 onward."}
{"id":198,"question":"How to detect memory leaks in Java?","options":{"a":"By using GC logs and profiling tools like VisualVM, JConsole, or JProfiler","b":"By running System.gc()","c":"By monitoring stack memory","d":"By disabling threads"},"answer":"a","explanation":"Memory leaks can be detected using profiling tools, heap dumps, and analyzing GC logs."}
{"id":199,"question":"What is ClassLoader? Types of class loaders?","options":{"a":"Loads classes into memory; types include Bootstrap, Extension, Application, and custom loaders","b":"Handles garbage collection","c":"Creates threads","d":"Compiles Java code"},"answer":"a","explanation":"ClassLoader loads Java classes into memory; main types include Bootstrap, Extension, Application, and user-defined loaders."}
{"id":200,"question":"What is JIT compiler?","options":{"a":"Interpreter for Java","b":"Just-In-Time compiler that converts bytecode to native code at runtime","c":"Compiler for native libraries","d":"Garbage collector"},"answer":"b","explanation":"JIT compiler improves performance by compiling bytecode into native machine code during runtime execution."}
{"id":201,"question":"How do annotations work internally?","options":{"a":"Through reflection and bytecode processing","b":"By adding new keywords","c":"By changing JVM settings","d":"By creating subclasses automatically"},"answer":"a","explanation":"Annotations are metadata processed at compile time or runtime using reflection and annotation processors."}
{"id":202,"question":"How to create custom annotations?","options":{"a":"By extending Annotation class","b":"By using @interface with retention and target policies","c":"By creating abstract classes","d":"By subclassing Object"},"answer":"b","explanation":"Custom annotations are created with @interface and meta-annotations like @Retention and @Target."}
{"id":203,"question":"What is annotation processing in Java?","options":{"a":"Using annotations for reflection only","b":"Tools/APIs process annotations at compile-time to generate code or configurations","c":"Using annotations for debugging","d":"Annotations always change bytecode"},"answer":"b","explanation":"Annotation processing uses tools like apt or javax.annotation.processing API to process annotations at compile-time."}
{"id":204,"question":"What are lambdas and how do they work internally?","options":{"a":"They are anonymous classes compiled as inner classes","b":"They are syntactic sugar implemented using invokedynamic","c":"They are macros expanded at compile-time","d":"They are reflection-based"},"answer":"b","explanation":"Lambdas are implemented using invokedynamic and converted to functional interfaces at runtime."}
{"id":205,"question":"Explain Type Erasure in Generics.","options":{"a":"Generics are replaced with Object at runtime, removing type info","b":"Generics are stored as metadata","c":"Generics create new classes per type","d":"Generics exist only in JVM"},"answer":"a","explanation":"Type Erasure removes generic type info at runtime, replacing with Object or bounded type."}
{"id":206,"question":"How are Generics implemented internally?","options":{"a":"Using templates like C++","b":"Using type erasure with casting and bridge methods","c":"By creating separate bytecode per type","d":"By JVM native instructions"},"answer":"b","explanation":"Generics are implemented via type erasure, where type parameters are erased and casts/bridge methods maintain type safety."}
{"id":207,"question":"Explain bounded vs unbounded wildcards.","options":{"a":"Bounded uses ? extends/super, unbounded is just ?","b":"Bounded is faster","c":"Unbounded allows only numbers","d":"Both are the same"},"answer":"a","explanation":"Bounded wildcards (? extends T / ? super T) restrict types; unbounded wildcard (?) accepts any type."}
{"id":208,"question":"What is raw type in Java?","options":{"a":"A generic type used without specifying type parameters","b":"A primitive type","c":"A type erased class","d":"A default type in JVM"},"answer":"a","explanation":"A raw type is a generic class used without type parameters, e.g., List instead of List<String>."}
{"id":209,"question":"How would you make a list thread-safe?","options":{"a":"By using Collections.synchronizedList() or CopyOnWriteArrayList","b":"By using LinkedList","c":"By using volatile variables","d":"By disabling threads"},"answer":"a","explanation":"Thread-safe lists can be created using Collections.synchronizedList() or concurrent classes like CopyOnWriteArrayList."}
{"id":210,"question":"How to avoid deadlock in concurrent programming?","options":{"a":"Avoid nested locks, use lock ordering, timeouts, and tryLock","b":"Always use synchronized","c":"Use more threads","d":"Ignore concurrency"},"answer":"a","explanation":"Deadlock can be prevented by consistent lock ordering, avoiding nested locks, and using timeouts or tryLock."}
{"id":211,"question":"Difference between Spring and Spring Boot.","options":{"a":"Spring Boot is a subset of Spring with auto-configuration and starter dependencies","b":"Spring is lighter than Spring Boot","c":"Spring Boot replaces Spring","d":"Spring Boot is unrelated to Spring"},"answer":"a","explanation":"Spring Boot builds on Spring, adding auto-configuration, embedded servers, and starters for rapid development."}
{"id":212,"question":"What is dependency injection and how is it implemented in Spring?","options":{"a":"Creating dependencies inside class","b":"Providing dependencies externally via constructors, setters, or annotations","c":"Using static variables","d":"Using inheritance"},"answer":"b","explanation":"Dependency Injection in Spring provides objects via constructors, setters, or @Autowired, instead of creating them directly."}
{"id":213,"question":"Difference between @Component, @Service, @Repository, and @Controller.","options":{"a":"All are identical","b":"They are stereotypes with semantic roles: generic bean, service, DAO, and web controller","c":"Only @Controller creates beans","d":"@Repository is for Spring Boot only"},"answer":"b","explanation":"All create Spring beans, but with semantic meaning: @Component (generic), @Service (business logic), @Repository (DAO with exception translation), @Controller (web MVC)." }
{"id":214,"question":"What is the role of @Autowired and how does it work?","options":{"a":"Marks beans for logging","b":"Injects dependencies by type from the Spring context","c":"Creates new objects","d":"Runs background threads"},"answer":"b","explanation":"@Autowired tells Spring to resolve and inject a matching bean from the context by type (and optionally qualifier)." }
{"id":215,"question":"How does Spring Boot auto-configuration work?","options":{"a":"By using @EnableAutoConfiguration and conditionally configuring beans based on classpath and properties","b":"By manually creating beans","c":"By disabling configuration","d":"By creating only default beans"},"answer":"a","explanation":"Spring Boot auto-configuration checks the classpath and conditions, automatically providing beans using @EnableAutoConfiguration." }
{"id":216,"question":"What are the starter dependencies in Spring Boot?","options":{"a":"Pre-configured Maven/Gradle dependencies for common use cases","b":"Custom JDK classes","c":"Only database drivers","d":"Only web dependencies"},"answer":"a","explanation":"Starter dependencies are pre-packaged dependencies like spring-boot-starter-web, reducing boilerplate setup."}
{"id":217,"question":"What is @SpringBootApplication composed of?","options":{"a":"@Configuration + @EnableAutoConfiguration + @ComponentScan","b":"@Controller + @Service + @Repository","c":"@Bean + @Import + @Qualifier","d":"@Autowired + @Qualifier"},"answer":"a","explanation":"@SpringBootApplication is a meta-annotation combining @Configuration, @EnableAutoConfiguration, and @ComponentScan."}
{"id":218,"question":"How does component scanning work in Spring Boot?","options":{"a":"Scans only JDK packages","b":"Scans packages from the main application class downward to register beans","c":"Scans only database packages","d":"Scans all classpath automatically"},"answer":"b","explanation":"Spring Boot scans packages starting from the package of the main class to register beans annotated with stereotypes."}
{"id":219,"question":"How do profiles work in Spring Boot?","options":{"a":"Profiles allow defining different beans and configs for environments like dev, test, prod","b":"Profiles are for user authentication","c":"Profiles replace dependencies","d":"Profiles manage only logging"},"answer":"a","explanation":"Profiles allow beans and configurations to be conditionally loaded based on active profile (dev, test, prod)."}
{"id":220,"question":"What are beans in Spring? Lifecycle?","options":{"a":"Objects managed by Spring IoC container; lifecycle includes instantiation, dependency injection, initialization, and destruction","b":"Any object created in Java","c":"Only entities in DB","d":"Only controllers"},"answer":"a","explanation":"Beans are managed objects in Spring context; lifecycle steps: instantiation → dependency injection → initialization (@PostConstruct/init) → destruction (@PreDestroy/destroy)." }
{"id":221,"question":"Difference between ApplicationContext and BeanFactory.","options":{"a":"Both are identical","b":"ApplicationContext is advanced, supports AOP/events, BeanFactory is basic","c":"BeanFactory supports internationalization, ApplicationContext does not","d":"ApplicationContext is slower and less used"},"answer":"b","explanation":"BeanFactory is the basic IoC container, while ApplicationContext extends it with features like AOP, internationalization, events, and annotation support."}
{"id":222,"question":"How to define a custom scope in Spring?","options":{"a":"By adding @Scope only","b":"By implementing Scope interface and registering via CustomScopeConfigurer","c":"By using @Bean","d":"By using @Qualifier"},"answer":"b","explanation":"Custom scopes are defined by implementing org.springframework.beans.factory.config.Scope and registering with CustomScopeConfigurer."}
{"id":223,"question":"What is AOP? Explain with use-case.","options":{"a":"Aspect-Oriented Programming for separating cross-cutting concerns like logging, security","b":"A type of ORM","c":"A caching mechanism","d":"A container for beans"},"answer":"a","explanation":"AOP modularizes cross-cutting concerns (e.g., logging, security) separately from business logic using aspects, advices, and join points."}
{"id":224,"question":"Difference between cross-cutting concern and business logic?","options":{"a":"Cross-cutting concern is core business requirement, business logic is auxiliary","b":"Business logic handles main features, cross-cutting concerns like logging, transactions apply across features","c":"Both are same","d":"Business logic is handled by AOP"},"answer":"b","explanation":"Business logic implements main functionality, while cross-cutting concerns like logging, security, and transactions span across multiple modules."}
{"id":225,"question":"How to implement custom annotations with AOP?","options":{"a":"By creating @interface and using reflection only","b":"By defining annotation, applying Aspect with @Around/@Before/@After advice","c":"By overriding methods","d":"By using @Autowired"},"answer":"b","explanation":"Custom annotations can be created with @interface, then handled using AOP aspects to apply logic at join points."}
{"id":226,"question":"What is the use of @Transactional?","options":{"a":"Marks beans for caching","b":"Manages transactions automatically with rollback/commit policies","c":"Marks a bean as singleton","d":"Used only for logging"},"answer":"b","explanation":"@Transactional defines transactional boundaries, handling commit/rollback automatically based on success or exceptions."}
{"id":227,"question":"What is the difference between programmatic and declarative transaction management?","options":{"a":"Programmatic uses annotations, declarative uses TransactionTemplate","b":"Programmatic uses code (TransactionTemplate/PlatformTransactionManager), declarative uses annotations (@Transactional)","c":"Both are same","d":"Declarative is slower"},"answer":"b","explanation":"Programmatic requires explicit code for transaction boundaries, while declarative uses annotations and AOP proxies."}
{"id":228,"question":"Explain propagation types in transaction management.","options":{"a":"They define logging behavior","b":"They define how existing/new transactions are handled when method is called","c":"They define bean scopes","d":"They define exception handling"},"answer":"b","explanation":"Propagation types (e.g., REQUIRED, REQUIRES_NEW, NESTED) define whether a method joins, suspends, or starts a new transaction."}
{"id":229,"question":"How does Spring handle circular dependency?","options":{"a":"It throws error always","b":"It uses setter injection and proxies to resolve circular references","c":"It ignores dependencies","d":"It restarts context"},"answer":"b","explanation":"Spring resolves circular dependencies mainly via setter injection and proxying beans when possible; constructor cycles cause exceptions."}
{"id":230,"question":"What is the difference between @Value, @ConfigurationProperties, and Environment?","options":{"a":"@Value is for simple values, @ConfigurationProperties binds groups, Environment provides runtime property access","b":"All are identical","c":"Environment is for logging only","d":"@Value is for beans only"},"answer":"a","explanation":"@Value injects single values, @ConfigurationProperties binds entire property groups to POJOs, Environment provides programmatic property access."}
{"id":231,"question":"Explain RestTemplate vs WebClient.","options":{"a":"RestTemplate is synchronous/blocking, WebClient is reactive/non-blocking","b":"RestTemplate is reactive, WebClient is blocking","c":"Both are reactive","d":"WebClient only supports GET"},"answer":"a","explanation":"RestTemplate uses blocking I/O; WebClient (Spring WebFlux) uses reactive, non-blocking I/O for scalability."}
{"id":232,"question":"What is reactive programming in Spring?","options":{"a":"Programming with Threads","b":"Programming with async, non-blocking streams of data","c":"Programming with Servlets","d":"Programming with inheritance"},"answer":"b","explanation":"Reactive programming in Spring (WebFlux, Project Reactor) is about non-blocking async streams using Publisher, Subscriber, Mono, Flux."}
{"id":233,"question":"Difference between Mono and Flux?","options":{"a":"Mono handles 0..1 elements, Flux handles 0..N elements","b":"Mono handles arrays, Flux handles lists","c":"Mono is blocking, Flux is non-blocking","d":"Mono is synchronous, Flux is async"},"answer":"a","explanation":"Mono represents a single value or empty, Flux represents a stream of 0..N values in reactive programming."}
{"id":234,"question":"What is Spring WebFlux?","options":{"a":"A replacement for Spring MVC","b":"A reactive-stack web framework built on Project Reactor","c":"A caching framework","d":"A DB framework"},"answer":"b","explanation":"Spring WebFlux is a reactive web framework supporting non-blocking, asynchronous request handling, built on Reactor."}
{"id":235,"question":"How to secure a REST API using Spring Security?","options":{"a":"By disabling security","b":"By using authentication, authorization filters, and configuring HttpSecurity","c":"By using only HTTPS","d":"By using @Transactional"},"answer":"b","explanation":"Spring Security secures REST APIs via authentication/authorization, filters, and HttpSecurity config."}
{"id":236,"question":"Difference between permitAll() and authenticated()?","options":{"a":"permitAll() allows all requests without authentication, authenticated() requires logged-in user","b":"Both require authentication","c":"Both disable security","d":"permitAll() requires admin role"},"answer":"a","explanation":"permitAll() lets anyone access, authenticated() requires a valid authenticated user."}
{"id":237,"question":"What is CSRF and how to handle it in Spring?","options":{"a":"Cross-Site Request Forgery, handled by CSRF tokens in forms","b":"Cross-Site Resource Fetching, handled by CORS","c":"Caching Sensitive Resource Files, handled by cache-control","d":"Cross-Service Request Filtering"},"answer":"a","explanation":"CSRF is an attack where unauthorized commands are submitted; Spring Security protects with CSRF tokens by default."}
{"id":238,"question":"What is AuthenticationManager?","options":{"a":"An interface for managing authentication process in Spring Security","b":"A bean factory","c":"A class loader","d":"A transaction manager"},"answer":"a","explanation":"AuthenticationManager processes authentication requests and returns an Authentication object if successful."}
{"id":239,"question":"How to implement custom authentication in Spring Security?","options":{"a":"By extending UserDetailsService and configuring AuthenticationProvider","b":"By disabling security","c":"By using only LDAP","d":"By overriding Object class"},"answer":"a","explanation":"Custom authentication can be implemented via UserDetailsService with custom AuthenticationProvider logic."}
{"id":240,"question":"What are filters and interceptors?","options":{"a":"Filters apply to requests before controllers, interceptors intercept at method level","b":"Both are identical","c":"Filters are for DB, interceptors for caching","d":"Filters only apply to views"},"answer":"a","explanation":"Servlet Filters pre-process requests/responses, while Spring Interceptors handle pre/post-controller logic."}
{"id":241,"question":"What is the difference between Filter and HandlerInterceptor?","options":{"a":"Filter is servlet-based, Interceptor is Spring MVC based","b":"Interceptor runs before/after controller, Filter runs before servlet container processing","c":"Both same","d":"Filter runs only after response"},"answer":"a","explanation":"Filters are servlet-based, Interceptors are Spring MVC based and work around controller execution."}
{"id":242,"question":"How does Spring handle exceptions?","options":{"a":"By logging only","b":"By using @ExceptionHandler, @ControllerAdvice, HandlerExceptionResolver","c":"By restarting context","d":"By ignoring them"},"answer":"b","explanation":"Spring handles exceptions using @ExceptionHandler in controllers, @ControllerAdvice for global handling, and resolvers."}
{"id":243,"question":"What is the difference between @ControllerAdvice and @ExceptionHandler?","options":{"a":"@ControllerAdvice handles globally, @ExceptionHandler handles per-controller","b":"Both same","c":"@ExceptionHandler works only with AOP","d":"@ControllerAdvice works only in REST"},"answer":"a","explanation":"@ExceptionHandler handles exceptions locally in a controller; @ControllerAdvice applies to all controllers globally."}
{"id":244,"question":"How to return consistent error responses in Spring REST?","options":{"a":"By using @ControllerAdvice + @ExceptionHandler to format error responses","b":"By disabling exceptions","c":"By using printStackTrace","d":"By sending plain text"},"answer":"a","explanation":"Consistent error responses are achieved by global exception handling with @ControllerAdvice + @ExceptionHandler returning structured error objects."}
{"id":245,"question":"How to create custom validators in Spring Boot?","options":{"a":"By extending ConstraintValidator and annotating field with custom annotation","b":"By overriding equals()","c":"By using static methods","d":"By subclassing Object"},"answer":"a","explanation":"Custom validators are created by defining annotation and implementing ConstraintValidator interface."}
{"id":246,"question":"Difference between validation groups and constraints?","options":{"a":"Groups allow applying constraints conditionally, constraints define validation rules","b":"Both are identical","c":"Constraints are runtime only, groups are compile-time","d":"Constraints apply only to Strings"},"answer":"a","explanation":"Constraints are rules like @NotNull, @Size, while validation groups allow applying them conditionally."}
{"id":247,"question":"What is the use of @Valid and @Validated?","options":{"a":"@Valid is JSR-303 standard, @Validated is Spring-specific for groups","b":"Both identical","c":"@Valid works only for Strings","d":"@Validated is for autowiring"},"answer":"a","explanation":"@Valid triggers JSR-303 validation, @Validated adds Spring-specific features like validation groups."}
{"id":248,"question":"How to use Swagger/OpenAPI in Spring Boot?","options":{"a":"By enabling DevTools","b":"By adding springdoc-openapi or springfox dependency and annotating controllers","c":"By using @Autowired","d":"By using @Repository"},"answer":"b","explanation":"Swagger/OpenAPI is integrated by adding libraries like springdoc-openapi or springfox, then documenting APIs with annotations such as @Operation and @ApiResponse."}
{"id":249,"question":"Difference between @PathVariable and @RequestParam.","options":{"a":"@PathVariable extracts values from URI path, @RequestParam extracts from query parameters","b":"@PathVariable works only with POST, @RequestParam only with GET","c":"Both are identical","d":"@RequestParam is for headers"},"answer":"a","explanation":"@PathVariable binds dynamic values from URI path, while @RequestParam binds query string parameters."}
{"id":250,"question":"What is HATEOAS?","options":{"a":"A database feature","b":"Hypermedia As The Engine Of Application State; adds links to REST responses","c":"A caching algorithm","d":"A Spring Boot starter"},"answer":"b","explanation":"HATEOAS enriches REST APIs by providing hypermedia links in responses, guiding clients on possible next actions."}
{"id":251,"question":"How does @Async work in Spring Boot?","options":{"a":"Runs methods synchronously","b":"Executes methods asynchronously in a separate thread pool","c":"Disables transactions","d":"Blocks threads"},"answer":"b","explanation":"@Async executes methods asynchronously using TaskExecutor, enabling non-blocking background processing."}
{"id":252,"question":"What is Spring Scheduler? Cron jobs?","options":{"a":"A scheduler for JVM GC","b":"Spring's scheduling support to run tasks at fixed rate/cron expressions","c":"Only for batch jobs","d":"Database scheduler"},"answer":"b","explanation":"Spring Scheduler allows tasks to be executed periodically or via cron expressions using @Scheduled annotation."}
{"id":253,"question":"How to publish and listen to events in Spring?","options":{"a":"By using Observer pattern manually","b":"By using ApplicationEventPublisher and @EventListener","c":"By using @Autowired","d":"By overriding Object"},"answer":"b","explanation":"Spring events can be published using ApplicationEventPublisher and consumed with @EventListener."}
{"id":254,"question":"Difference between synchronous and asynchronous event publishing.","options":{"a":"Synchronous blocks publisher until all listeners finish; asynchronous does not","b":"Synchronous is faster","c":"Asynchronous works only with DB","d":"Both are same"},"answer":"a","explanation":"In synchronous mode, publisher waits for listeners to complete; in async, events are processed concurrently."}
{"id":255,"question":"How does caching work in Spring Boot?","options":{"a":"By writing to local files","b":"By using annotations like @Cacheable, @CachePut, @CacheEvict with cache managers","c":"By using JDBC only","d":"By disabling GC"},"answer":"b","explanation":"Spring Boot caching abstracts caching with annotations and supports providers like ConcurrentMap, Redis, EhCache."}
{"id":256,"question":"How to use Redis for caching?","options":{"a":"By enabling JPA","b":"By adding spring-boot-starter-data-redis and configuring RedisCacheManager","c":"By using @Entity","d":"By overriding Object"},"answer":"b","explanation":"Redis caching is enabled by adding Redis dependencies, configuring RedisCacheManager, and using Spring’s caching annotations."}
{"id":257,"question":"How to monitor Spring Boot applications?","options":{"a":"Using Actuator, Micrometer, Prometheus, Grafana","b":"By checking logs only","c":"By JVM shutdown hooks","d":"By disabling threads"},"answer":"a","explanation":"Spring Boot apps are monitored using Actuator endpoints, Micrometer metrics, and external tools like Prometheus/Grafana."}
{"id":258,"question":"What are Spring Boot Actuators?","options":{"a":"Libraries for UI","b":"Endpoints providing operational info like health, metrics, env","c":"Annotations for validation","d":"Bean lifecycle handlers"},"answer":"b","explanation":"Actuators expose production-ready endpoints for monitoring and managing applications (health, metrics, env, logs)."}
{"id":259,"question":"How to expose custom metrics?","options":{"a":"By using Micrometer’s MeterRegistry to define counters/gauges/timers","b":"By adding @Autowired","c":"By creating new controllers","d":"By using @Entity"},"answer":"a","explanation":"Custom metrics can be exposed by registering meters with Micrometer’s MeterRegistry, accessible via Actuator."}
{"id":260,"question":"How to configure a datasource manually?","options":{"a":"By creating DataSource bean in @Configuration","b":"By using @Autowired","c":"By enabling DevTools","d":"By disabling JPA"},"answer":"a","explanation":"Datasources can be manually configured by defining DataSource beans in a @Configuration class with properties."}
{"id":261,"question":"What is Spring Data JPA?","options":{"a":"A caching library","b":"A repository abstraction over JPA for database operations","c":"A servlet engine","d":"A logging library"},"answer":"b","explanation":"Spring Data JPA simplifies database access by providing repository interfaces over JPA with derived queries."}
{"id":262,"question":"What are derived query methods?","options":{"a":"Queries defined in annotations","b":"Queries generated from method names like findByName","c":"Queries written in SQL only","d":"Queries that require reflection"},"answer":"b","explanation":"Derived query methods are created from method names in repository interfaces, e.g., findByEmail or countByStatus."}
{"id":263,"question":"Difference between CrudRepository, JpaRepository, PagingAndSortingRepository.","options":{"a":"CrudRepository basic CRUD, PagingAndSorting adds pagination/sorting, JpaRepository adds JPA-specific features","b":"All are identical","c":"JpaRepository is slower","d":"CrudRepository is thread-safe, JpaRepository is not"},"answer":"a","explanation":"CrudRepository provides CRUD, PagingAndSorting adds pagination/sorting, JpaRepository adds advanced JPA features."}
{"id":264,"question":"How to handle pagination in Spring Data?","options":{"a":"By writing custom SQL","b":"By using Pageable and Page<T> interfaces","c":"By overriding toString()","d":"By caching results"},"answer":"b","explanation":"Pagination is supported by passing Pageable to repository methods and retrieving Page<T> results."}
{"id":265,"question":"What is query-by-example (QBE)?","options":{"a":"A way to write SQL","b":"A Spring Data feature to query by providing a probe object","c":"A type of caching","d":"A logging mechanism"},"answer":"b","explanation":"QBE allows querying by creating a probe object with filled fields, matched by ExampleMatcher."}
{"id":266,"question":"How to write native queries in JPA?","options":{"a":"Using @Query with nativeQuery=true","b":"By overriding equals()","c":"By disabling JPQL","d":"By using @Entity"},"answer":"a","explanation":"Native SQL queries can be written using @Query(value = ..., nativeQuery = true) in repositories."}
{"id":267,"question":"Difference between EntityManager and JdbcTemplate.","options":{"a":"EntityManager is JPA API for ORM, JdbcTemplate is Spring abstraction for raw JDBC","b":"Both are identical","c":"JdbcTemplate handles ORM, EntityManager does not","d":"EntityManager is faster always"},"answer":"a","explanation":"EntityManager manages entities via ORM (JPA), while JdbcTemplate simplifies direct JDBC operations."}
{"id":268,"question":"What is @EntityGraph?","options":{"a":"Defines queries","b":"Specifies fetch plans for associations to avoid N+1","c":"A caching annotation","d":"A transaction marker"},"answer":"b","explanation":"@EntityGraph customizes how associations are fetched (eager vs lazy) in queries, avoiding N+1 problem."}
{"id":269,"question":"What is lazy vs eager loading?","options":{"a":"Lazy loads associations when accessed, eager loads immediately","b":"Eager loads faster always","c":"Lazy is for caching only","d":"Both are same"},"answer":"a","explanation":"Lazy loading defers association fetch until accessed, eager loads associations immediately with the entity."}
{"id":270,"question":"How does dirty checking work in JPA?","options":{"a":"By tracking object changes in persistence context and syncing to DB on flush","b":"By reloading entities each time","c":"By using cache only","d":"By disabling transactions"},"answer":"a","explanation":"Dirty checking detects changes in managed entities within persistence context and updates DB automatically on flush/commit."}
{"id":271,"question":"What is the N+1 select problem? Solution?","options":{"a":"Occurs when 1 query loads entities, then N queries load associations; solved using fetch joins/EntityGraph","b":"Occurs with caching","c":"Occurs with transaction propagation","d":"Solved by disabling lazy loading"},"answer":"a","explanation":"The N+1 problem happens when fetching one entity causes multiple queries for associations; solved via fetch joins, batch fetching, or @EntityGraph."}
{"id":272,"question":"Difference between optimistic and pessimistic locking.","options":{"a":"Optimistic assumes no conflict and checks at commit, pessimistic locks data immediately","b":"Both lock rows immediately","c":"Optimistic is slower always","d":"Pessimistic uses cache only"},"answer":"a","explanation":"Optimistic locking uses versioning to detect conflicts, pessimistic locking acquires DB locks to prevent conflicts."}
{"id":273,"question":"What is @DynamicUpdate in Hibernate?","options":{"a":"For dynamic proxies","b":"Updates only modified columns in SQL UPDATE","c":"Always updates all fields","d":"For caching"},"answer":"b","explanation":"@DynamicUpdate optimizes performance by generating SQL UPDATE with only modified fields."}
{"id":274,"question":"How does @Inheritance work in JPA?","options":{"a":"Maps class hierarchies to DB tables using strategies like SINGLE_TABLE, JOINED, TABLE_PER_CLASS","b":"Used only for interfaces","c":"Used for caching","d":"Used for enums"},"answer":"a","explanation":"@Inheritance defines how entity hierarchies are mapped to DB tables using SINGLE_TABLE, JOINED, or TABLE_PER_CLASS."}
{"id":275,"question":"What is a DTO? Why is it used?","options":{"a":"A Data Transfer Object used to carry data between layers","b":"A caching object","c":"A database entity","d":"A thread pool"},"answer":"a","explanation":"DTOs transfer data between layers without exposing entities, improving decoupling and security."}
{"id":276,"question":"How to map DTO to Entity and vice versa?","options":{"a":"By writing manual converters or using libraries like ModelMapper/MapStruct","b":"By using @EntityGraph","c":"By caching","d":"By using reflection only"},"answer":"a","explanation":"DTOs can be mapped to entities manually or automatically with libraries like ModelMapper or MapStruct."}
{"id":277,"question":"What is ModelMapper?","options":{"a":"A logging library","b":"A library that simplifies mapping between DTOs and entities","c":"A database connector","d":"A caching provider"},"answer":"b","explanation":"ModelMapper is a Java library that automates object mapping between DTOs and entities, reducing boilerplate code."}
{"id":278,"question":"What are common performance pitfalls in Spring Boot applications?","options":{"a":"Using too many controllers","b":"Excessive database calls, N+1 queries, poor caching, unbounded threads","c":"Using annotations","d":"Using YAML configs"},"answer":"b","explanation":"Common issues include N+1 queries, lack of caching, improper thread pools, heavy serialization, and excessive DB calls."}
{"id":279,"question":"How to use Spring Boot with Docker?","options":{"a":"By adding @Docker annotation","b":"By creating Dockerfile with JAR, exposing ports, and building image","c":"By enabling DevTools","d":"By disabling Actuator"},"answer":"b","explanation":"Spring Boot can be containerized by building a JAR, writing a Dockerfile with FROM openjdk, ADD jar, EXPOSE port, and running with Docker."}
{"id":280,"question":"How to externalize configurations in Spring Boot?","options":{"a":"By hardcoding values","b":"By using application.properties/yml, environment variables, config server","c":"By using static variables","d":"By caching values"},"answer":"b","explanation":"Spring Boot externalizes configs via properties/yml, environment variables, command-line args, or Spring Cloud Config Server."}
{"id":281,"question":"What is Spring Config Server?","options":{"a":"A DB service","b":"A centralized server that manages external configuration for microservices","c":"A cache store","d":"A logging server"},"answer":"b","explanation":"Spring Cloud Config Server provides centralized configuration management for distributed systems using Git or other sources."}
{"id":282,"question":"Difference between Spring Cloud Config and application.yml?","options":{"a":"application.yml is local, Config Server provides centralized external config","b":"Both are identical","c":"Config Server only works with databases","d":"application.yml is only for testing"},"answer":"a","explanation":"application.yml is app-local, while Spring Cloud Config serves centralized configs to multiple microservices."}
{"id":283,"question":"How to use Spring Cloud with Eureka?","options":{"a":"By configuring Eureka Server and clients with @EnableEurekaServer and @EnableEurekaClient","b":"By using @Autowired","c":"By using JDBC","d":"By adding @Repository"},"answer":"a","explanation":"Spring Cloud Eureka provides service discovery; Eureka Server registers services and Eureka Clients discover them."}
{"id":284,"question":"What is a circuit breaker in Spring Cloud?","options":{"a":"A pattern to stop cascading failures by halting requests to failing services","b":"A logging mechanism","c":"A thread pool","d":"A DB transaction manager"},"answer":"a","explanation":"Circuit breakers (via Resilience4j/Hystrix) prevent cascading failures by halting calls to failing services temporarily."}
{"id":285,"question":"What is Spring Cloud Gateway? Difference with Zuul?","options":{"a":"Gateway is built on Netty, reactive, Zuul 1 is servlet-based","b":"Both identical","c":"Zuul is newer","d":"Gateway is only for databases"},"answer":"a","explanation":"Spring Cloud Gateway is a reactive API gateway on Netty/Reactor, whereas Zuul 1 is servlet-based and synchronous."}
{"id":286,"question":"How to write filters in Spring Gateway?","options":{"a":"By using @Autowired","b":"By implementing GlobalFilter or GatewayFilter and defining routes","c":"By overriding toString()","d":"By using JDBC"},"answer":"b","explanation":"Custom filters are created by implementing GlobalFilter or GatewayFilter and adding them to route definitions."}
{"id":287,"question":"What is Resilience4j and how is it integrated?","options":{"a":"A DB framework","b":"A lightweight fault-tolerance library integrated via Spring Boot starters","c":"A caching provider","d":"A thread pool manager"},"answer":"b","explanation":"Resilience4j provides circuit breaker, retry, bulkhead, and rate limiting, integrated via Spring Boot starters."}
{"id":288,"question":"What is Sleuth and Zipkin? How do they work?","options":{"a":"Sleuth adds tracing IDs to logs, Zipkin collects and visualizes traces","b":"Sleuth is for caching, Zipkin is for DB","c":"Both are for transactions","d":"Both are for authentication"},"answer":"a","explanation":"Spring Cloud Sleuth propagates trace/span IDs across services, and Zipkin collects/visualizes distributed tracing data."}
{"id":289,"question":"What is Spring Retry?","options":{"a":"A transaction manager","b":"A library to retry operations with policies like exponential backoff","c":"A DB query optimizer","d":"A GC algorithm"},"answer":"b","explanation":"Spring Retry provides retry mechanisms with policies like fixed delay or exponential backoff for failed operations."}
{"id":290,"question":"What are distributed transactions and how to manage them in Spring?","options":{"a":"Transactions spanning multiple services/resources, managed using XA or Saga pattern","b":"Transactions in a single DB","c":"Only caching","d":"Only for async tasks"},"answer":"a","explanation":"Distributed transactions span services/resources; managed via XA (JTA) or Saga pattern for eventual consistency."}
{"id":291,"question":"What is Saga Pattern?","options":{"a":"A transaction rollback algorithm","b":"A distributed transaction pattern using local transactions and compensation","c":"A DB index","d":"A caching method"},"answer":"b","explanation":"Saga breaks distributed transactions into local transactions with compensating actions to ensure consistency."}
{"id":292,"question":"How to implement service discovery?","options":{"a":"By using Eureka, Consul, or Zookeeper","b":"By using @Autowired","c":"By caching","d":"By using @Transactional"},"answer":"a","explanation":"Service discovery is implemented using tools like Eureka, Consul, or Zookeeper to register and locate services dynamically."}
{"id":293,"question":"Difference between Ribbon and Spring Cloud LoadBalancer?","options":{"a":"Ribbon is client-side LB (deprecated), Spring Cloud LoadBalancer is newer, reactive","b":"Both identical","c":"Ribbon is reactive, LoadBalancer is not","d":"LoadBalancer is deprecated"},"answer":"a","explanation":"Ribbon is Netflix’s client-side load balancer (now deprecated), replaced by Spring Cloud LoadBalancer with reactive support."}
{"id":294,"question":"What is Hystrix? Why is it deprecated?","options":{"a":"A Netflix circuit breaker, deprecated due to lack of updates and replaced by Resilience4j","b":"A caching framework","c":"A Spring library","d":"A database driver"},"answer":"a","explanation":"Hystrix is a Netflix circuit breaker library, deprecated because it is no longer maintained; Resilience4j is its replacement."}
{"id":295,"question":"What is FeignClient and how does it work?","options":{"a":"A declarative REST client in Spring Cloud that abstracts HTTP calls via interfaces","b":"A JDBC client","c":"A logging client","d":"A thread pool"},"answer":"a","explanation":"FeignClient makes REST calls via interfaces with annotations like @GetMapping, auto-implemented by Spring Cloud."}
{"id":296,"question":"Difference between OpenFeign and RestTemplate?","options":{"a":"OpenFeign is declarative, RestTemplate is imperative","b":"Both identical","c":"RestTemplate is reactive","d":"Feign is only for DB"},"answer":"a","explanation":"Feign abstracts REST calls using interfaces and annotations, while RestTemplate requires manual coding of REST requests."}
{"id":297,"question":"How does OAuth2 work with Spring Security?","options":{"a":"It authenticates via tokens from an authorization server, enforcing scopes and roles","b":"It works only with JDBC","c":"It replaces JWT","d":"It’s for caching"},"answer":"a","explanation":"OAuth2 provides delegated access using access tokens issued by an authorization server, integrated via Spring Security."}
{"id":298,"question":"What is JWT? How is it integrated with Spring Boot?","options":{"a":"JSON Web Token for stateless authentication, integrated via filters in Spring Security","b":"A DB format","c":"A logging system","d":"A JVM tool"},"answer":"a","explanation":"JWT is a compact token format for authentication/authorization, integrated in Spring Boot via filters and token providers."}
{"id":299,"question":"How to secure microservices with API Gateway?","options":{"a":"By centralizing authentication/authorization at gateway layer before routing requests","b":"By disabling authentication","c":"By using @Autowired","d":"By caching responses"},"answer":"a","explanation":"API Gateway secures microservices by handling authentication/authorization, rate limiting, and request validation at entry point."}
{"id":300,"question":"What is Spring Session?","options":{"a":"Manages user sessions centrally across distributed apps","b":"A DB manager","c":"A logging tool","d":"A cache"},"answer":"a","explanation":"Spring Session manages HTTP sessions across distributed environments using stores like Redis or JDBC."}
{"id":301,"question":"How to implement rate limiting in Spring Boot?","options":{"a":"By using Resilience4j RateLimiter, Bucket4j, or API Gateway filters","b":"By using @Autowired","c":"By using @Entity","d":"By disabling threads"},"answer":"a","explanation":"Rate limiting can be implemented using Resilience4j’s RateLimiter, Bucket4j, or via API Gateway filters."}
{"id":302,"question":"What is service registry and how does it help?","options":{"a":"A central database for transactions","b":"A registry like Eureka that tracks service instances for discovery","c":"A cache","d":"A DB lock"},"answer":"b","explanation":"Service registries (Eureka, Consul) maintain service instance locations, enabling dynamic discovery and load balancing."}
{"id":303,"question":"How to trace a request across multiple services?","options":{"a":"By using tracing libraries like Sleuth and Zipkin/Jaeger with correlation IDs","b":"By caching requests","c":"By logging only","d":"By database triggers"},"answer":"a","explanation":"Distributed tracing tools like Sleuth with Zipkin/Jaeger propagate trace/span IDs across services to track requests end-to-end."}
{"id":304,"question":"How to implement custom starter in Spring Boot?","options":{"a":"By creating @Configuration classes and exposing beans via META-INF/spring.factories or AutoConfiguration","b":"By using @Autowired only","c":"By adding @Bean in main class","d":"By using @ComponentScan"},"answer":"a","explanation":"Custom starters are created with auto-configuration classes, registered in META-INF/spring.factories (or spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports in newer versions)."}
{"id":305,"question":"How to test Spring Boot applications?","options":{"a":"Using JUnit, Mockito, Spring Test, and @SpringBootTest","b":"By disabling beans","c":"By running in production","d":"By using only logs"},"answer":"a","explanation":"Spring Boot testing is done with @SpringBootTest, @WebMvcTest, MockMvc, JUnit, and Mockito for unit/integration testing."}
{"id":306,"question":"What is MockMvc and when to use it?","options":{"a":"A tool for database testing","b":"A Spring testing utility to test MVC controllers without starting server","c":"A caching tool","d":"A logging utility"},"answer":"b","explanation":"MockMvc tests Spring MVC controllers in isolation without deploying to a servlet container."}
{"id":307,"question":"How to mock external services in integration tests?","options":{"a":"By disabling tests","b":"By using MockWebServer, WireMock, or Mockito","c":"By using @Entity","d":"By using @Value"},"answer":"b","explanation":"External services can be mocked with WireMock, MockWebServer, or stubbing using Mockito in integration tests."}
{"id":308,"question":"What is @DataJpaTest?","options":{"a":"A Spring Boot annotation for testing only JPA components with in-memory DB","b":"An annotation for full context","c":"Used for caching","d":"Used for REST API testing"},"answer":"a","explanation":"@DataJpaTest configures tests for JPA repositories with embedded databases, scanning only JPA-related components."}
{"id":309,"question":"What is TestContainers and how to use with Spring Boot?","options":{"a":"A library to run lightweight containers for testing databases and services","b":"A Spring annotation","c":"A cache manager","d":"A Docker alternative"},"answer":"a","explanation":"TestContainers run real services (like PostgreSQL, Kafka, Redis) in Docker containers for integration tests in Spring Boot."}
{"id":310,"question":"What is the difference between Unit Test and Integration Test in Spring?","options":{"a":"Unit tests test entire app, integration tests test small units","b":"Unit tests isolate a class, integration tests verify multiple components working together","c":"Both are same","d":"Integration tests are faster"},"answer":"b","explanation":"Unit tests test single classes/methods in isolation; integration tests verify multiple components working together with Spring context."}
{"id":311,"question":"How is a microservice different from a monolith?","options":{"a":"Microservices are tightly coupled, monolith is loosely coupled","b":"Monolith is one deployable unit, microservices are independent services","c":"Both are identical","d":"Monolith is always faster"},"answer":"b","explanation":"Monolith is a single deployable unit; microservices are independent, loosely coupled services deployed separately."}
{"id":312,"question":"What are the advantages and disadvantages of microservices?","options":{"a":"Advantages: scalability, flexibility; Disadvantages: complexity, distributed debugging","b":"Advantages: simplicity, Disadvantages: no scaling","c":"Only advantages","d":"Only disadvantages"},"answer":"a","explanation":"Microservices offer scalability, independent deployments, and fault isolation, but add complexity in communication, debugging, and data consistency."}
{"id":313,"question":"How do microservices communicate?","options":{"a":"Only via direct DB calls","b":"Via synchronous (REST/gRPC) and asynchronous (Kafka/RabbitMQ) communication","c":"Only via JMS","d":"Only via SOAP"},"answer":"b","explanation":"Microservices communicate synchronously via REST/gRPC and asynchronously via message brokers like Kafka or RabbitMQ."}
{"id":314,"question":"What is service discovery?","options":{"a":"The process of finding available service instances dynamically","b":"A caching process","c":"A database lookup","d":"A thread scheduler"},"answer":"a","explanation":"Service discovery dynamically registers and locates microservices using tools like Eureka, Consul, or Zookeeper."}
{"id":315,"question":"What is Eureka and how does it work?","options":{"a":"A database engine","b":"A service registry from Netflix; services register with Eureka server and clients discover them","c":"A thread pool manager","d":"A cache provider"},"answer":"b","explanation":"Eureka is a Netflix service registry; Eureka Server holds service registry, and Eureka Clients register/discover services."}
{"id":316,"question":"What is API Gateway in microservices?","options":{"a":"A DB manager","b":"A single entry point for routing, security, monitoring across services","c":"A caching layer","d":"A test framework"},"answer":"b","explanation":"API Gateway provides a single entry point, handling routing, authentication, rate limiting, and monitoring in microservices."}
{"id":317,"question":"How does Spring Cloud Gateway work?","options":{"a":"By defining filters and routes to handle requests reactively","b":"By caching responses","c":"By managing DB connections","d":"By disabling transactions"},"answer":"a","explanation":"Spring Cloud Gateway uses filters and routes for reactive, non-blocking request routing and cross-cutting concerns."}
{"id":318,"question":"What are edge services?","options":{"a":"Services for DB storage","b":"Services at the boundary handling routing, security, monitoring","c":"Services for logging only","d":"Cache-only services"},"answer":"b","explanation":"Edge services are gateway-like services handling routing, authentication, authorization, and monitoring at system boundaries."}
{"id":319,"question":"Explain the importance of bounded contexts in microservices.","options":{"a":"They define shared DB schemas","b":"They ensure each microservice has clear domain boundaries, reducing coupling","c":"They enforce caching","d":"They handle monitoring"},"answer":"b","explanation":"Bounded contexts in DDD ensure microservices focus on specific business domains, reducing coupling and complexity."}
{"id":320,"question":"What is domain-driven design (DDD)?","options":{"a":"A UI design pattern","b":"An approach where software structure is modeled around business domains","c":"A caching algorithm","d":"A database schema"},"answer":"b","explanation":"DDD emphasizes modeling software around business domains and ubiquitous language, leading to modular and domain-focused services."}
{"id":321,"question":"What is the difference between orchestration and choreography in microservices?","options":{"a":"Orchestration uses central controller, choreography uses event-driven interactions","b":"Choreography uses controller, orchestration uses events","c":"Both are identical","d":"Orchestration is for DB"},"answer":"a","explanation":"Orchestration coordinates services via central workflow (e.g., Saga orchestrator), while choreography uses events to coordinate services."}
{"id":322,"question":"What is a distributed transaction?","options":{"a":"A transaction across multiple services/resources","b":"A transaction within single DB","c":"A cache operation","d":"A thread-safe transaction"},"answer":"a","explanation":"Distributed transactions span multiple services/resources; managed using XA or patterns like Saga."}
{"id":323,"question":"How do you achieve eventual consistency?","options":{"a":"By using synchronous DB locks","b":"By using asynchronous messaging, retries, and compensating transactions","c":"By using static variables","d":"By using single monolith DB"},"answer":"b","explanation":"Eventual consistency is achieved using async messaging (Kafka), retries, and Saga pattern with compensating actions."}
{"id":324,"question":"Explain the Saga pattern with example.","options":{"a":"A transaction rollback algorithm","b":"A distributed transaction pattern using local transactions and compensating actions, e.g., order service with payment rollback","c":"A DB cache","d":"A JVM GC"},"answer":"b","explanation":"Saga executes local transactions per service; on failure, compensating actions rollback changes, e.g., cancelling order if payment fails."}
{"id":325,"question":"How would you handle inter-service communication failures?","options":{"a":"By retrying, using circuit breakers, fallbacks, and message queues","b":"By restarting services","c":"By ignoring errors","d":"By disabling async"},"answer":"a","explanation":"Failures are handled with retries, circuit breakers, fallbacks, bulkheads, and async queues to avoid cascading failures."}
{"id":326,"question":"What is circuit breaker pattern?","options":{"a":"A retry loop","b":"A pattern to stop calling a failing service temporarily","c":"A logging mechanism","d":"A caching method"},"answer":"b","explanation":"Circuit breaker detects failures and halts requests temporarily, allowing system to recover before retrying."}
{"id":327,"question":"How does Resilience4j work?","options":{"a":"Provides caching","b":"Provides fault-tolerance with circuit breaker, retry, bulkhead, rate limiter","c":"Provides DB transactions","d":"Provides GC optimization"},"answer":"b","explanation":"Resilience4j is a lightweight fault-tolerance library offering circuit breaker, retry, bulkhead, and rate limiting."}
{"id":328,"question":"What is rate limiting? How do you implement it?","options":{"a":"Restricting number of requests; implement via API Gateway filters, Resilience4j, or Bucket4j","b":"Restricting number of DB calls only","c":"Restricting number of threads","d":"Restricting number of logs"},"answer":"a","explanation":"Rate limiting restricts requests to prevent overload; implemented with API Gateway filters or libraries like Resilience4j, Bucket4j."}
{"id":329,"question":"How to design idempotent APIs?","options":{"a":"By ensuring repeated requests don’t change outcome, using unique request IDs, PUT/DELETE methods","b":"By using GET only","c":"By avoiding retries","d":"By caching only"},"answer":"a","explanation":"Idempotent APIs ensure multiple identical requests have same effect; achieved with unique request IDs, PUT semantics, and safe retries."}
{"id":330,"question":"What is a fallback method in circuit breaker?","options":{"a":"A method that retries endlessly","b":"A backup method invoked when primary call fails","c":"A cache refresh method","d":"A logging hook"},"answer":"b","explanation":"Fallback methods provide alternate responses when main service calls fail under circuit breaker pattern."}
{"id":331,"question":"What is load balancing? Types?","options":{"a":"Distributing traffic across instances; types include client-side, server-side, DNS-based","b":"Caching responses","c":"Database sharding","d":"Thread synchronization"},"answer":"a","explanation":"Load balancing distributes traffic across instances; types include client-side (Ribbon), server-side (NGINX, ELB), and DNS-based."}
{"id":332,"question":"Difference between client-side and server-side load balancing.","options":{"a":"Client-side decides target instance locally, server-side delegates to load balancer service","b":"Both are identical","c":"Server-side is faster always","d":"Client-side works only with monoliths"},"answer":"a","explanation":"Client-side load balancing (e.g., Ribbon) selects instance on client side; server-side (e.g., NGINX, ELB) routes requests centrally."}
{"id":333,"question":"What is Ribbon? Is it still used?","options":{"a":"A database library","b":"Netflix client-side load balancer (deprecated, replaced by Spring Cloud LoadBalancer)","c":"A logging API","d":"A cache tool"},"answer":"b","explanation":"Ribbon was Netflix’s client-side load balancer; it’s now deprecated and replaced by Spring Cloud LoadBalancer."}
{"id":334,"question":"What is Spring Cloud LoadBalancer?","options":{"a":"A replacement for Ribbon providing reactive, pluggable load balancing","b":"A database driver","c":"A cache manager","d":"A scheduler"},"answer":"a","explanation":"Spring Cloud LoadBalancer is a modern client-side load balancer replacing Ribbon, supporting reactive apps."}
{"id":335,"question":"What is API versioning and how to implement it?","options":{"a":"Maintaining multiple versions of APIs via URI, headers, or params","b":"Changing DB schema version","c":"Versioning only configs","d":"Not needed in microservices"},"answer":"a","explanation":"API versioning is done using URI (/v1/), request headers, or query parameters to manage backward compatibility."}
{"id":336,"question":"How to secure microservices using OAuth2?","options":{"a":"By using API keys","b":"By delegating auth to an authorization server issuing tokens","c":"By disabling authentication","d":"By using static configs"},"answer":"b","explanation":"OAuth2 secures microservices by using an authorization server to issue tokens which services validate for access control."}
{"id":337,"question":"What is JWT? How to use it in microservices?","options":{"a":"JSON Web Token for stateless authentication, used as bearer token across services","b":"A DB engine","c":"A logging format","d":"A JVM tool"},"answer":"a","explanation":"JWTs store claims securely and are used in microservices for authentication/authorization by passing bearer tokens in requests."}
{"id":338,"question":"What is token propagation?","options":{"a":"Passing authentication token from one service to another in a request chain","b":"Storing tokens in DB","c":"Refreshing tokens","d":"Caching tokens"},"answer":"a","explanation":"Token propagation ensures authentication/authorization tokens are passed downstream across service calls."}
{"id":339,"question":"How do you handle secrets in microservices?","options":{"a":"By hardcoding in code","b":"By storing in secure vaults like HashiCorp Vault, AWS Secrets Manager, or Config Server encryption","c":"By keeping in Git","d":"By logging them"},"answer":"b","explanation":"Secrets should be stored securely in vaults or encrypted config servers, never hardcoded or committed to code."}
{"id":340,"question":"What is config server?","options":{"a":"A caching service","b":"A centralized configuration server for externalized properties","c":"A DB replication service","d":"A monitoring tool"},"answer":"b","explanation":"Spring Cloud Config Server provides centralized externalized configuration for distributed services."}
{"id":341,"question":"How to refresh config without restarting services?","options":{"a":"By reloading beans manually","b":"By using Spring Cloud Bus with @RefreshScope and /actuator/refresh","c":"By clearing cache","d":"By restarting DB"},"answer":"b","explanation":"Configs can be refreshed dynamically with @RefreshScope beans and Spring Cloud Bus broadcasting refresh events."}
{"id":342,"question":"What is bootstrap.yml vs application.yml?","options":{"a":"bootstrap.yml loads first for config server setup, application.yml loads later for app configs","b":"application.yml loads first","c":"Both identical","d":"bootstrap.yml is deprecated"},"answer":"a","explanation":"bootstrap.yml is used for early initialization like config server, while application.yml defines app-level properties."}
{"id":343,"question":"What is centralized logging?","options":{"a":"Storing logs on each server","b":"Aggregating logs from all services into a central system like ELK/EFK","c":"Using only console logs","d":"Only storing errors"},"answer":"b","explanation":"Centralized logging aggregates logs into systems like ELK or EFK, enabling search, analysis, and monitoring across services."}
{"id":344,"question":"How does distributed tracing work?","options":{"a":"By logging only","b":"By assigning trace/span IDs and propagating them across services","c":"By storing logs in DB","d":"By disabling async"},"answer":"b","explanation":"Distributed tracing attaches trace/span IDs to requests and propagates them across services, collected by tools like Zipkin/Jaeger."}
{"id":345,"question":"What is Sleuth? What is Zipkin?","options":{"a":"Sleuth adds trace IDs to logs, Zipkin collects and visualizes traces","b":"Both are DB tools","c":"Both are caching tools","d":"Sleuth is deprecated"},"answer":"a","explanation":"Sleuth propagates trace/span IDs in logs, while Zipkin is a distributed tracing system for collecting and visualizing traces."}
{"id":346,"question":"What are span and trace IDs?","options":{"a":"Trace ID identifies entire request flow, Span ID identifies single operation","b":"Both are same","c":"Span ID is global, Trace ID is local","d":"Trace ID is per thread"},"answer":"a","explanation":"Trace ID represents a full request across services; Span ID represents a single operation within that trace."}
{"id":347,"question":"What is an anti-corruption layer?","options":{"a":"A caching method","b":"A layer that isolates legacy systems from new ones via adapters","c":"A DB partitioning method","d":"A logging tool"},"answer":"b","explanation":"An Anti-Corruption Layer translates between legacy and modern systems, preventing legacy models from polluting new domains."}
{"id":348,"question":"What is the database-per-service pattern?","options":{"a":"Each service has its own database schema for loose coupling","b":"All services share one DB","c":"Each service has its own schema but shared DB server","d":"No DB used"},"answer":"a","explanation":"Database-per-service ensures loose coupling and independence by giving each microservice its own database."}
{"id":349,"question":"What are shared-nothing architectures?","options":{"a":"Architecture where services share DB and state","b":"Architecture where services do not share state, DB, or storage","c":"Architecture for caching","d":"Architecture for single monolith"},"answer":"b","explanation":"Shared-nothing architecture ensures services are independent with isolated state, storage, and DBs."}
{"id":350,"question":"What is CQRS? When to use it?","options":{"a":"Command Query Responsibility Segregation, used to separate read/write models for scalability","b":"A DB sharding method","c":"A logging method","d":"A cache strategy"},"answer":"a","explanation":"CQRS separates read and write models, improving scalability and flexibility in event-driven architectures."}
{"id":351,"question":"What is Event Sourcing?","options":{"a":"Storing only final state","b":"Storing all changes as events and reconstructing state from them","c":"A caching algorithm","d":"A DB partitioning strategy"},"answer":"b","explanation":"Event Sourcing persists all state changes as events, allowing rebuilding of entity state and audit history."}
{"id":352,"question":"What is a sidecar pattern?","options":{"a":"Running helper components (logging, monitoring, proxy) alongside main service in same pod/container","b":"Splitting DB","c":"A cache method","d":"Monolithic pattern"},"answer":"a","explanation":"Sidecar pattern deploys auxiliary components like monitoring, logging, or service mesh proxies alongside main app container."}
{"id":353,"question":"What is service mesh? What tools are used?","options":{"a":"A network layer for service-to-service communication with tools like Istio, Linkerd","b":"A DB sharding system","c":"A cache","d":"A logging library"},"answer":"a","explanation":"Service mesh provides secure, observable, and reliable service-to-service communication with tools like Istio, Linkerd."}
{"id":354,"question":"What is Istio and Linkerd?","options":{"a":"Both are service mesh implementations","b":"Both are logging libraries","c":"Both are DB tools","d":"Both are deprecated"},"answer":"a","explanation":"Istio and Linkerd are service mesh frameworks providing traffic management, security, and observability."}
{"id":355,"question":"How do you monitor microservices?","options":{"a":"By ignoring logs","b":"By using centralized logging, distributed tracing, metrics with Prometheus/Grafana","c":"By restarting services","d":"By using only System.out.println"},"answer":"b","explanation":"Microservices are monitored with centralized logging (ELK), distributed tracing (Sleuth/Zipkin), and metrics (Prometheus/Grafana)."}
{"id":356,"question":"What is Prometheus and Grafana?","options":{"a":"Prometheus is monitoring/alerting system, Grafana visualizes metrics","b":"Both are DBs","c":"Both are caches","d":"Both are message queues"},"answer":"a","explanation":"Prometheus scrapes and stores time-series metrics; Grafana visualizes and dashboards them."}
{"id":357,"question":"What are metrics and observability?","options":{"a":"Metrics are logs, observability is DB state","b":"Metrics are quantitative data, observability is ability to infer system state from logs, metrics, traces","c":"Both are identical","d":"Metrics are only for CPU"},"answer":"b","explanation":"Metrics provide quantitative data, while observability combines logs, metrics, and traces to understand system behavior."}
{"id":358,"question":"What is health check API?","options":{"a":"An API to return application health status","b":"A DB backup tool","c":"A GC monitor","d":"A load balancer"},"answer":"a","explanation":"Health check APIs return app status (UP/DOWN) for monitoring and load balancers to ensure availability."}
{"id":359,"question":"How to perform health checks in Spring Boot?","options":{"a":"By using Spring Boot Actuator /health endpoint","b":"By manually writing SQL queries","c":"By restarting services","d":"By logging only"},"answer":"a","explanation":"Spring Boot Actuator provides /health endpoint with application and dependency status for monitoring."}
{"id":360,"question":"How do you debug issues in a distributed environment?","options":{"a":"Check a single log file","b":"Use centralized logging, tracing (trace IDs), metrics, and correlation IDs","c":"Restart everything","d":"Print stack traces to console"},"answer":"b","explanation":"Aggregate logs (ELK/EFK), use distributed tracing (Sleuth/Zipkin/Jaeger) with correlation IDs, and monitor metrics to follow requests across services."}
{"id":361,"question":"What are dead-letter queues?","options":{"a":"Queues that never receive messages","b":"Queues holding messages that failed processing after retries","c":"Queues for high priority tasks","d":"Temporary caches"},"answer":"b","explanation":"DLQs store poison messages for later inspection after max retry attempts fail."}
{"id":362,"question":"How do you manage service versioning?","options":{"a":"Overwrite old APIs","b":"Use semantic versioning and API versioning (URI/headers)","c":"Use random tags","d":"Rely on docs only"},"answer":"b","explanation":"Apply semver for services and expose API versions via URIs or headers to evolve safely."}
{"id":363,"question":"How to maintain backward compatibility?","options":{"a":"Remove fields immediately","b":"Additive changes, tolerate unknown fields, support multiple versions","c":"Force clients to upgrade","d":"Break contracts often"},"answer":"b","explanation":"Prefer additive, non-breaking changes and support parallel API versions during migration."}
{"id":364,"question":"How do you deploy multiple microservices together?","options":{"a":"Single repo only","b":"Use CI/CD pipelines per service with orchestrated releases","c":"Manual SSH scripts","d":"Zip files"},"answer":"b","explanation":"Each service has its pipeline; release trains or orchestrated deployments coordinate cross-service changes."}
{"id":365,"question":"What is blue-green deployment?","options":{"a":"Two DBs for HA","b":"Run two identical envs (blue/green) and switch traffic","c":"Random canaries","d":"Shadow reads"},"answer":"b","explanation":"Deploy new version to idle env; switch traffic when healthy to minimize downtime/rollback risk."}
{"id":366,"question":"What is canary deployment?","options":{"a":"All-or-nothing rollout","b":"Gradually route small % of traffic to new version","c":"DB migration only","d":"Hotfix pattern"},"answer":"b","explanation":"Canary releases limit blast radius by exposing a subset of users to the new version first."}
{"id":367,"question":"How to rollback a faulty microservice?","options":{"a":"Patch in prod","b":"Re-route to previous version, revert image/tag, or flip blue/green","c":"Restart pods only","d":"Increase retries"},"answer":"b","explanation":"Keep prior version ready (image/tag/green env) and switch traffic or redeploy previous image."}
{"id":368,"question":"What are the common microservices pitfalls?","options":{"a":"Over-coupling, chatty calls, shared DB, lack of observability","b":"Too many tests","c":"Using CI/CD","d":"Small teams"},"answer":"a","explanation":"Tight coupling, synchronous chains, shared data stores, and weak ops/monitoring cause fragility."}
{"id":369,"question":"How would you refactor a monolith into microservices?","options":{"a":"Big bang rewrite","b":"Strangle pattern: carve bounded contexts, expose via gateway, migrate gradually","c":"Copy-paste code","d":"Split by tables"},"answer":"b","explanation":"Use strangler fig pattern guided by domain boundaries to reduce risk and ship incrementally."}
{"id":370,"question":"What is a shared library in microservices?","options":{"a":"A common DB schema","b":"Reusable library for cross-cutting concerns (e.g., auth, logging)","c":"A central service","d":"A cache"},"answer":"b","explanation":"Extract common cross-cutting code into versioned libraries to avoid duplication while avoiding tight coupling."}
{"id":371,"question":"What is API composition?","options":{"a":"DB joins across services","b":"Aggregating responses from multiple services for a client","c":"Batch writes","d":"CQRS writes"},"answer":"b","explanation":"A composer/gateway aggregates data from multiple services into a single client response."}
{"id":372,"question":"What is service granularity?","options":{"a":"Number of pods","b":"How big a service’s responsibility is","c":"Log size","d":"DB size"},"answer":"b","explanation":"Choose scope by domain boundaries; too fine causes chatty comms, too coarse recreates monoliths."}
{"id":373,"question":"How do you manage dependencies between microservices?","options":{"a":"Tight compile-time coupling","b":"Versioned APIs, contracts, event schemas, and backward compatibility","c":"Share DTO jars always","d":"Shared DB tables"},"answer":"b","explanation":"Use versioned contracts and loose coupling via events or stable APIs; avoid sharing DBs."}
{"id":374,"question":"How to test microservices independently?","options":{"a":"Only E2E tests","b":"Unit + component + contract tests with mocks/stubs","c":"Manual QA only","d":"Production testing"},"answer":"b","explanation":"Layered testing isolates services with mocks and uses contract tests to validate integrations."}
{"id":375,"question":"What is consumer-driven contract testing?","options":{"a":"Load testing","b":"Consumers define expectations that providers verify","c":"UI testing","d":"DB migration tests"},"answer":"b","explanation":"CDCT ensures providers meet the concrete expectations of their consumers, preventing breaking changes."}
{"id":376,"question":"What is Pact and how does it work?","options":{"a":"A tracing tool","b":"A CDCT tool where consumers publish contracts the provider validates","c":"A cache","d":"A DB driver"},"answer":"b","explanation":"Pact stores consumer contracts in a broker; providers run verification tests against them."}
{"id":377,"question":"How do you handle timeouts in microservices?","options":{"a":"No timeouts","b":"Set per-call timeouts, retries with backoff, and circuit breakers","c":"Infinite retries","d":"Rely on OS"},"answer":"b","explanation":"Combine sane timeouts with retry/backoff and circuit breakers to avoid resource exhaustion."}
{"id":378,"question":"What is asynchronous communication?","options":{"a":"Blocking HTTP calls","b":"Message-driven/event-driven interactions via brokers","c":"Shared memory","d":"File polling only"},"answer":"b","explanation":"Async uses brokers (Kafka/RabbitMQ) to decouple producers and consumers and improve resilience."}
{"id":379,"question":"When to use synchronous vs asynchronous communication?","options":{"a":"Always async","b":"Sync for request/response needs; async for decoupling, buffering, and eventual consistency","c":"Always sync","d":"Randomly choose"},"answer":"b","explanation":"Pick sync for immediate results; async for scale, resilience, and workflow decoupling."}
{"id":380,"question":"What is eventual consistency vs strong consistency?","options":{"a":"Eventual may be briefly stale; strong guarantees up-to-date reads","b":"Both identical","c":"Eventual is always wrong","d":"Strong is async"},"answer":"a","explanation":"Eventual consistency accepts temporary divergence; strong consistency ensures reads reflect latest committed writes."}
{"id":381,"question":"How to handle large payloads in microservices?","options":{"a":"Embed files in JSON","b":"Use object storage + references, streaming, compression, pagination","c":"Split randomly","d":"Increase timeouts only"},"answer":"b","explanation":"Store blobs externally and stream; paginate and compress to reduce latency/memory."}
{"id":382,"question":"How to implement file upload in a microservice?","options":{"a":"POST binary to service DB","b":"Use pre-signed URLs to object storage; service manages metadata","c":"Email files","d":"Base64 in JSON"},"answer":"b","explanation":"Offload to object storage via pre-signed URLs and keep metadata in the service."}
{"id":383,"question":"What is throttling?","options":{"a":"DB sharding","b":"Limiting request rate per client to protect capacity","c":"Log rotation","d":"Cache invalidation"},"answer":"b","explanation":"Rate limits prevent abuse and overload; implement per key/IP/route quotas."}
{"id":384,"question":"How do you scale a microservice?","options":{"a":"More logs","b":"Scale horizontally, optimize hot paths, cache, and tune DB","c":"Disable auth","d":"Add sleeps"},"answer":"b","explanation":"Add instances (HPA), optimize code/DB, add caching and queues; eliminate bottlenecks."}
{"id":385,"question":"What is horizontal vs vertical scaling?","options":{"a":"Horizontal adds instances; vertical adds resources to one instance","b":"Horizontal adds RAM; vertical adds nodes","c":"Opposite of A","d":"Scaling logs"},"answer":"a","explanation":"Scale out by adding replicas; scale up by giving a node more CPU/RAM."}
{"id":386,"question":"What is container orchestration?","options":{"a":"Manual container start","b":"Automated scheduling, scaling, healing, and networking of containers","c":"Compiling images","d":"Logging only"},"answer":"b","explanation":"Orchestrators (Kubernetes) manage container lifecycles, scale, and networking declaratively."}
{"id":387,"question":"How does Kubernetes support microservices?","options":{"a":"By hosting monoliths only","b":"Provides deployments, services, ingress, autoscaling, config/secrets, and service discovery","c":"DB-only features","d":"Tracing only"},"answer":"b","explanation":"K8s primitives (Deployments, Services, Ingress, HPA, ConfigMaps/Secrets, DNS) enable scalable, discoverable microservices."}
