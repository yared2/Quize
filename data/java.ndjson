{"id":101,"question":"What does the Java Memory Model guarantee with 'volatile' writes?","options":{"a":"Atomicity for all operations on the variable including ++","b":"Visibility and ordering (happens-before) from writer to subsequent readers","c":"Mutual exclusion for the variable","d":"Prevents false sharing"},"answer":"b","explanation":"volatile guarantees visibility + ordering (write → read happens-before); it does not provide atomic compound ops or mutual exclusion."}
{"id":102,"question":"Which statement about 'synchronized' is TRUE?","options":{"a":"It only provides visibility, not mutual exclusion","b":"It establishes happens-before from monitor exit to subsequent monitor enter on the same monitor","c":"It is faster than ReentrantLock in all cases","d":"It supports tryLock() with timeout"},"answer":"b","explanation":"Exiting a monitor happens-before a subsequent enter on the same monitor. It provides mutual exclusion; ReentrantLock adds features like tryLock()."}
{"id":103,"question":"Which operation on ConcurrentHashMap is atomic w.r.t. mapping presence?","options":{"a":"getOrDefault","b":"computeIfAbsent","c":"replaceAll","d":"forEach"},"answer":"b","explanation":"computeIfAbsent atomically checks presence and inserts the computed value for a key if absent."}
{"id":104,"question":"In Streams, which is a terminal operation?","options":{"a":"map","b":"peek","c":"collect","d":"filter"},"answer":"c","explanation":"collect is terminal; map, peek, filter are intermediate."}
{"id":105,"question":"Parallel streams: which is a common pitfall?","options":{"a":"Using stateless, associative reductions","b":"Using thread-safe collectors like toConcurrentMap","c":"Using non-associative accumulation (e.g., floating-point order sensitive)","d":"Using unordered sources"},"answer":"c","explanation":"Parallel reductions require associativity; non-associative ops can yield inconsistent results."}
{"id":106,"question":"CompletableFuture: which combines two independent futures and returns when BOTH complete?","options":{"a":"anyOf","b":"allOf","c":"applyToEither","d":"acceptEither"},"answer":"b","explanation":"allOf waits for all futures to complete; anyOf waits for any one."}
{"id":107,"question":"Which is TRUE about ForkJoinPool?","options":{"a":"Best for blocking I/O tasks","b":"Uses work-stealing among worker queues","c":"Requires explicit Thread creation","d":"Cannot run recursive tasks"},"answer":"b","explanation":"ForkJoinPool uses work-stealing; it’s designed for compute-bound, fine-grained tasks."}
{"id":108,"question":"Which GC is designed for low-pause times with region-based heap and is default in modern JDKs?","options":{"a":"Serial GC","b":"CMS","c":"G1 GC","d":"Epsilon"},"answer":"c","explanation":"G1 is region-based and default in recent JDK LTS versions (e.g., 17, 21), targeting predictable pauses."}
{"id":109,"question":"Which GC aims for ultra-low pauses with concurrent compaction and barrier-heavy design?","options":{"a":"Parallel GC","b":"ZGC","c":"Serial GC","d":"Shenandoah is the same as ZGC implementation"},"answer":"b","explanation":"ZGC is a concurrent, regioned, colored-pointers GC targeting very low pauses; Shenandoah is similar in goal but distinct."}
{"id":110,"question":"What does 'escape analysis' enable in HotSpot JIT?","options":{"a":"Turning objects into primitives","b":"Stack allocation and scalar replacement of non-escaping objects","c":"Ahead-of-time compilation only","d":"Disabling bounds checks"},"answer":"b","explanation":"If an object doesn’t escape a method/thread, JIT can allocate on stack or eliminate it via scalar replacement."}
{"id":111,"question":"Which is TRUE about the 'happens-before' relation?","options":{"a":"It is equivalent to wall-clock time","b":"Program order within a single thread contributes to happens-before","c":"It only arises from locks, not volatiles","d":"It guarantees fairness of scheduling"},"answer":"b","explanation":"Within a single thread, actions are ordered; synchronization constructs (locks, volatiles) also create happens-before edges."}
{"id":112,"question":"Which class provides lock downgrading (write→read) semantics?","options":{"a":"ReentrantLock","b":"Semaphore","c":"ReentrantReadWriteLock","d":"StampedLock only"},"answer":"c","explanation":"ReentrantReadWriteLock allows acquiring write then downgrading to read while holding locks properly."}
{"id":113,"question":"What’s a safe pattern to avoid ThreadLocal memory leaks in pools?","options":{"a":"Never remove values","b":"Use static ThreadLocal","c":"Call remove() in finally after use","d":"Use WeakReference yourself"},"answer":"c","explanation":"In pooled threads, always remove ThreadLocal values in finally-blocks to avoid retention."}
{"id":114,"question":"Which Map removes entries when keys are no longer strongly referenced?","options":{"a":"LinkedHashMap with accessOrder=true","b":"WeakHashMap","c":"IdentityHashMap","d":"ConcurrentSkipListMap"},"answer":"b","explanation":"WeakHashMap uses weak keys; entries are cleared when keys are GC-eligible."}
{"id":115,"question":"LinkedHashMap can be used to build an LRU cache by overriding which method?","options":{"a":"hashCode","b":"remove","c":"removeEldestEntry","d":"putIfAbsent"},"answer":"c","explanation":"Override removeEldestEntry and set accessOrder=true to evict least recently used entries."}
{"id":116,"question":"Which statement about 'record' in Java is TRUE?","options":{"a":"Records are mutable by default","b":"Records implicitly extend java.lang.Record and are final","c":"Records cannot define methods","d":"Records cannot implement interfaces"},"answer":"b","explanation":"Records are final, implicitly extend Record, and can define methods and implement interfaces; components are final."}
{"id":117,"question":"Sealed classes: which is valid?","options":{"a":"A sealed class must list permitted subclasses","b":"A sealed class cannot have final subclasses","c":"Permits must be at runtime only","d":"Sealed classes replace access modifiers"},"answer":"a","explanation":"Sealed classes enumerate permitted subclasses; subclasses must be sealed, non-sealed, or final."}
{"id":118,"question":"Pattern matching for 'instanceof' mainly helps with:","options":{"a":"Eliminating switch","b":"Reducing casts after the check","c":"Overloading resolution","d":"Operator overloading"},"answer":"b","explanation":"Pattern matching binds a variable when the instanceof test succeeds, avoiding explicit casts."}
{"id":119,"question":"JPMS modules vs classpath: what’s a key advantage of modules?","options":{"a":"Faster I/O","b":"Stronger encapsulation and reliable configuration","c":"Automatic serialization","d":"Guaranteed ABI stability across JDKs"},"answer":"b","explanation":"Modules provide explicit dependencies/exports and strong encapsulation beyond classpath rules."}
{"id":120,"question":"Which NIO feature supports asynchronous file I/O on supporting platforms?","options":{"a":"FileInputStream","b":"AsynchronousFileChannel","c":"BufferedReader","d":"RandomAccessFile only"},"answer":"b","explanation":"AsynchronousFileChannel provides async I/O operations in NIO.2."}
{"id":121,"question":"Which statement about Optional is BEST practice?","options":{"a":"Use Optional for fields to model absence","b":"Return Optional in public APIs, don’t use it for fields","c":"Serialize Optionals","d":"Use Optional for parameters"},"answer":"b","explanation":"Optional is for return types to signal possible absence; avoid fields/params for performance/clarity."}
{"id":122,"question":"Which is TRUE about virtual threads (Project Loom)?","options":{"a":"They are OS threads","b":"They are user-mode threads scheduled by the JVM, enabling massive concurrency","c":"They require synchronized for correctness","d":"They replace ExecutorService"},"answer":"b","explanation":"Virtual threads are lightweight, JVM-scheduled (user-mode) threads; they work with existing executors/APIs."}
{"id":123,"question":"CompletableFuture: which composes dependent async tasks sequentially?","options":{"a":"thenApply","b":"thenCompose","c":"thenAcceptBoth","d":"runAfterBoth"},"answer":"b","explanation":"thenCompose flattens and chains dependent futures (async → async)."}
{"id":124,"question":"Which annotation retention allows reflection at runtime?","options":{"a":"SOURCE","b":"CLASS","c":"RUNTIME","d":"BINARY"},"answer":"c","explanation":"RUNTIME retention keeps annotations available to reflection during execution."}
{"id":125,"question":"Which is TRUE about equals & hashCode?","options":{"a":"Only equals must be consistent with hashCode","b":"If equals is overridden, hashCode must usually be overridden","c":"hashCode may change within a HashSet safely","d":"Using mutable fields in hashCode is harmless"},"answer":"b","explanation":"Objects equal to each other must produce equal hash codes; mutability in keys can break hashed collections."}
{"id":126,"question":"What does VarHandle provide over sun.misc.Unsafe?","options":{"a":"Private, unsupported API","b":"A standardized, safe, reflective access to variables with memory-order ops","c":"No atomic operations","d":"Deprecated since Java 9"},"answer":"b","explanation":"VarHandle is the standard supported API for low-level atomic/memory-ordered operations."}
{"id":127,"question":"Which Collector is safe and efficient for parallel streams to build a Map?","options":{"a":"Collectors.toMap (with default merger)","b":"Collectors.toConcurrentMap (with merger)","c":"Collectors.groupingBy without supplier","d":"Collectors.toUnmodifiableMap"},"answer":"b","explanation":"toConcurrentMap with a merge function is designed for concurrent accumulation."}
{"id":128,"question":"Which tool/flag pair enables class data sharing to speed startup?","options":{"a":"-Xshare:off with CDS archive","b":"CDS/AppCDS with -Xshare:on","c":"-verbose:class only","d":"JFR automatically does this"},"answer":"b","explanation":"CDS/AppCDS share class metadata across JVMs using archives; enable with -Xshare:on."}
{"id":129,"question":"Which synchronization primitive best coordinates a variable number of phased tasks?","options":{"a":"CountDownLatch","b":"CyclicBarrier only","c":"Phaser","d":"Semaphore"},"answer":"c","explanation":"Phaser supports dynamic registration and multiple phases; more flexible than CountDownLatch/Barrier."}
{"id":130,"question":"StampedLock optimistic read: main caveat?","options":{"a":"It blocks writers","b":"Must validate the stamp before trusting the read","c":"It upgrades automatically to write lock","d":"It replaces volatile"},"answer":"b","explanation":"Optimistic reads must call validate(stamp) to ensure no write occurred; otherwise retry."}
{"id":131,"question":"What is the main purpose of an API Gateway in microservices?","options":{"a":"Database normalization","b":"Centralized routing, security, and aggregation","c":"Managing CI/CD pipelines","d":"Scaling the database"},"answer":"b","explanation":"An API Gateway acts as a single entry point to route requests, handle authentication, rate limiting, and sometimes aggregate responses from multiple services."}
{"id":132,"question":"Why do microservices often use asynchronous communication?","options":{"a":"It ensures immediate consistency","b":"It reduces coupling and improves scalability","c":"It eliminates the need for APIs","d":"It guarantees no data loss"},"answer":"b","explanation":"Asynchronous communication (via Kafka, RabbitMQ, etc.) allows services to remain loosely coupled and scale independently without blocking requests."}
{"id":133,"question":"In microservices, what problem does service discovery solve?","options":{"a":"Caching frequently used data","b":"Finding network locations of running service instances","c":"Encrypting service traffic","d":"Deploying containers automatically"},"answer":"b","explanation":"Service discovery dynamically tracks and provides endpoints for service instances, as IP/port addresses may change frequently in cloud or containerized environments."}
{"id":134,"question":"Which pattern is used to handle failures gracefully in microservices?","options":{"a":"Singleton","b":"Circuit Breaker","c":"Observer","d":"Decorator"},"answer":"b","explanation":"The Circuit Breaker pattern prevents cascading failures by stopping requests to a failing service and allowing it to recover."}
{"id":135,"question":"Why is database-per-service recommended in microservices?","options":{"a":"It ensures every service has the same schema","b":"It enforces loose coupling and independent scaling","c":"It makes joins easier across services","d":"It allows all services to share a single cache"},"answer":"b","explanation":"A database-per-service ensures data ownership, independence, and prevents tight coupling between services."}
{"id":136,"question":"What’s the main drawback of distributed transactions in microservices?","options":{"a":"They are too fast","b":"They increase system coupling and complexity","c":"They eliminate consistency issues","d":"They prevent scaling"},"answer":"b","explanation":"Distributed transactions (like 2PC) add latency, complexity, and tight coupling, which goes against microservice principles."}
{"id":137,"question":"Which principle does the Saga pattern enforce in microservices?","options":{"a":"Immediate consistency","b":"Eventual consistency via local transactions","c":"Centralized transaction manager","d":"Database-per-cluster"},"answer":"b","explanation":"Saga breaks large distributed transactions into smaller local transactions coordinated via events, ensuring eventual consistency."}
{"id":138,"question":"What role does observability play in microservices?","options":{"a":"It manages scaling policies","b":"It provides visibility with logs, metrics, and traces","c":"It stores application secrets","d":"It ensures only stateless services run"},"answer":"b","explanation":"Observability (via tools like ELK, Prometheus, Grafana, Zipkin) helps monitor system health with logs, metrics, and distributed traces."}
{"id":139,"question":"Why is containerization (e.g., Docker) commonly used for microservices?","options":{"a":"It enforces strong typing in services","b":"It ensures consistent environments and portability","c":"It eliminates the need for APIs","d":"It avoids CI/CD pipelines"},"answer":"b","explanation":"Containers package microservices with dependencies, ensuring consistency across development, test, and production environments."}
{"id":140,"question":"What is the main challenge with inter-service communication in microservices?","options":{"a":"It makes debugging easier","b":"It introduces network latency and reliability concerns","c":"It prevents scaling","d":"It simplifies data consistency"},"answer":"b","explanation":"Since microservices communicate over the network, latency, retries, and reliability must be carefully handled with patterns like retries, timeouts, and circuit breakers."}
{"id":141,"question":"Explain the difference between == and .equals() in Java.","options":{"a":"== compares values, .equals() compares memory references","b":"== compares references, .equals() compares content","c":"Both compare only primitive values","d":"Both compare only object identity"},"answer":"b","explanation":"== checks reference equality (whether two references point to the same object), while .equals() checks logical equality, usually content."}
{"id":142,"question":"Why is String immutable in Java?","options":{"a":"To save memory","b":"To improve performance","c":"To ensure security, caching, and thread-safety","d":"Because JVM does not allow mutable objects"},"answer":"c","explanation":"String immutability ensures cached values (like hashCode), security in class loading, and thread-safety since multiple threads can share Strings safely."}
{"id":143,"question":"What is the difference between HashMap and ConcurrentHashMap?","options":{"a":"HashMap is synchronized, ConcurrentHashMap is not","b":"HashMap allows null keys/values, ConcurrentHashMap restricts nulls and supports concurrency","c":"Both are identical except for hashing algorithm","d":"ConcurrentHashMap uses linked lists only"},"answer":"b","explanation":"HashMap is not thread-safe and allows one null key, while ConcurrentHashMap is thread-safe and disallows null keys/values."}
{"id":144,"question":"Explain the concept of fail-fast vs fail-safe iterators.","options":{"a":"Fail-fast throws ConcurrentModificationException, fail-safe does not","b":"Fail-fast is thread-safe, fail-safe is not","c":"Fail-safe uses locks, fail-fast uses copies","d":"Fail-fast iterates slower"},"answer":"a","explanation":"Fail-fast iterators throw ConcurrentModificationException when collection is modified during iteration, while fail-safe iterators iterate over a copy and avoid exceptions."}
{"id":145,"question":"What is the significance of hashCode() and equals() method?","options":{"a":"They are used for JVM memory allocation","b":"They define object equality and affect collections like HashMap","c":"They are only used for Strings","d":"They are optional and unused in Java"},"answer":"b","explanation":"hashCode() and equals() determine how objects are compared and stored in hash-based collections like HashMap and HashSet."}
{"id":146,"question":"How does ArrayList work internally?","options":{"a":"Uses dynamic arrays that resize as needed","b":"Uses linked lists","c":"Uses hash tables","d":"Uses a tree structure"},"answer":"a","explanation":"ArrayList uses a resizable array; when capacity is exceeded, it creates a new array with larger size and copies elements over."}
{"id":147,"question":"What is the difference between ArrayList and LinkedList?","options":{"a":"ArrayList uses dynamic arrays, LinkedList uses doubly linked nodes","b":"ArrayList is faster for insertions, LinkedList is faster for random access","c":"Both use linked structures","d":"Both have identical performance"},"answer":"a","explanation":"ArrayList uses a resizable array for fast random access; LinkedList uses a doubly linked list, making insertions/deletions efficient but random access slower."}
{"id":148,"question":"How does Java handle memory management?","options":{"a":"Developers must manually allocate and free memory","b":"Uses automatic Garbage Collection for heap memory","c":"Memory is fixed and cannot be freed","d":"Only stack memory is managed"},"answer":"b","explanation":"Java handles memory automatically using Garbage Collection, reclaiming unused objects in heap memory."}
{"id":149,"question":"What is the role of the final keyword?","options":{"a":"Prevents class inheritance, method overriding, or reassignment of variables","b":"Used only for constants","c":"Marks a class as abstract","d":"Used only for memory optimization"},"answer":"a","explanation":"The final keyword prevents changes: final classes cannot be extended, final methods cannot be overridden, and final variables cannot be reassigned."}
{"id":150,"question":"How does Garbage Collection work in Java?","options":{"a":"Manually triggered by the programmer","b":"Automatically reclaims memory for unreachable objects","c":"Deletes stack frames","d":"Runs only when JVM shuts down"},"answer":"b","explanation":"Garbage Collection automatically reclaims memory from objects no longer referenced, preventing memory leaks."}
{"id":151,"question":"What is a WeakHashMap?","options":{"a":"A HashMap with weak thread-safety","b":"A map where keys are held with weak references and can be garbage collected","c":"A slower version of HashMap","d":"A map with only string keys"},"answer":"b","explanation":"WeakHashMap holds keys with weak references, allowing them to be garbage collected when no longer in ordinary use."}
{"id":152,"question":"How is synchronization achieved in Java?","options":{"a":"Using synchronized keyword, Locks, or concurrent utilities","b":"By using volatile variables","c":"By using static methods","d":"By avoiding threads"},"answer":"a","explanation":"Synchronization in Java is achieved using synchronized blocks/methods, explicit locks (ReentrantLock), and high-level concurrency utilities."}
{"id":153,"question":"What are the different thread states?","options":{"a":"Running, Waiting, Paused, Killed","b":"New, Runnable, Blocked, Waiting, Timed Waiting, Terminated","c":"Start, Run, Sleep, End","d":"Idle, Active, Paused"},"answer":"b","explanation":"Java threads can be in states: New, Runnable, Blocked, Waiting, Timed Waiting, or Terminated."}
{"id":154,"question":"What is the difference between Runnable and Callable?","options":{"a":"Runnable returns a result, Callable does not","b":"Callable returns a result and can throw exceptions, Runnable does not","c":"Both are identical","d":"Callable is used only for threads"},"answer":"b","explanation":"Runnable cannot return results or throw checked exceptions; Callable can return values and throw exceptions."}
{"id":155,"question":"What is thread starvation?","options":{"a":"When a thread consumes too many resources","b":"When a thread is blocked indefinitely due to lack of CPU access","c":"When thread priority is too high","d":"When threads are paused by the GC"},"answer":"b","explanation":"Thread starvation occurs when low-priority threads never get CPU time due to higher-priority threads dominating resources."}
{"id":156,"question":"What is the difference between wait(), sleep(), and yield()?","options":{"a":"wait() releases lock, sleep() pauses without releasing, yield() hints scheduler","b":"All three pause a thread the same way","c":"sleep() releases lock, wait() does not","d":"yield() is the same as wait()"},"answer":"a","explanation":"wait() releases monitor lock and waits, sleep() pauses but keeps lock, yield() suggests the scheduler to give other threads CPU."}
{"id":157,"question":"How does the volatile keyword work?","options":{"a":"Provides full synchronization","b":"Ensures visibility of changes across threads","c":"Prevents thread creation","d":"Locks an object"},"answer":"b","explanation":"volatile ensures that reads/writes to a variable are always done from main memory, guaranteeing visibility across threads."}
{"id":158,"question":"What is a race condition? How to prevent it?","options":{"a":"When multiple threads access shared data incorrectly; prevent using synchronization","b":"When threads finish tasks too quickly","c":"When two classes have same name","d":"When GC deletes objects prematurely"},"answer":"a","explanation":"A race condition occurs when multiple threads modify shared data simultaneously. It is prevented using synchronization, locks, or atomic classes."}
{"id":159,"question":"Explain ReentrantLock vs synchronized block.","options":{"a":"Both are identical","b":"ReentrantLock provides more features like tryLock() and fairness, unlike synchronized","c":"synchronized is faster and always preferred","d":"ReentrantLock cannot be reentrant"},"answer":"b","explanation":"ReentrantLock provides advanced features like fairness, tryLock, and interruptibility, whereas synchronized is simpler and built-in."}
{"id":160,"question":"What is thread pooling and how is it implemented?","options":{"a":"Creating new thread for each task","b":"Using Executor framework to reuse a fixed number of threads","c":"Allocating all CPU cores to one thread","d":"Using synchronized blocks only"},"answer":"b","explanation":"Thread pooling uses the Executor framework (like ThreadPoolExecutor) to reuse threads for multiple tasks, improving efficiency."}
{"id":161,"question":"What is the Fork/Join framework?","options":{"a":"A scheduling algorithm","b":"A framework to parallelize tasks by splitting into subtasks and combining results","c":"A networking API","d":"A way to handle exceptions"},"answer":"b","explanation":"The Fork/Join framework parallelizes large tasks into smaller ones (fork) and merges results (join) efficiently."}
{"id":162,"question":"Explain Stream API with examples.","options":{"a":"A library for handling files","b":"A library for functional-style operations on collections","c":"A networking API","d":"A concurrency framework"},"answer":"b","explanation":"The Stream API allows functional-style operations like map, filter, reduce on collections, enabling concise and parallelizable code."}
{"id":163,"question":"Difference between map() and flatMap() in Streams?","options":{"a":"map flattens results, flatMap does not","b":"map transforms elements, flatMap transforms and flattens nested structures","c":"Both are identical","d":"map is for lists, flatMap is for arrays"},"answer":"b","explanation":"map applies a function to each element and returns a Stream; flatMap applies a function and flattens nested results into a single Stream."}
{"id":164,"question":"What are functional interfaces?","options":{"a":"Interfaces with only abstract methods","b":"Interfaces with exactly one abstract method","c":"Interfaces with default methods only","d":"Interfaces used only for concurrency"},"answer":"b","explanation":"A functional interface has exactly one abstract method, making it suitable for lambda expressions and method references."}
{"id":165,"question":"What is the difference between Optional.of() and Optional.ofNullable()?","options":{"a":"Both throw NullPointerException for null values","b":"Optional.of() throws if null, Optional.ofNullable() allows null","c":"Optional.ofNullable() throws if null, Optional.of() allows null","d":"Both behave the same"},"answer":"b","explanation":"Optional.of() throws NullPointerException if the value is null, while Optional.ofNullable() safely creates an empty Optional for null values."}
{"id":166,"question":"What is method reference in Java?","options":{"a":"A reference to methods for debugging","b":"A shorthand for lambda expressions referring to methods","c":"A reflection-based call","d":"A special keyword in Java"},"answer":"b","explanation":"Method references (:: operator) are shorthand for lambdas that call existing methods, e.g., list.forEach(System.out::println)."}
{"id":167,"question":"How does Collectors.groupingBy() work?","options":{"a":"Groups elements into lists based on a classifier function","b":"Sorts elements","c":"Removes duplicates","d":"Splits a Stream into parallel chunks"},"answer":"a","explanation":"Collectors.groupingBy() groups stream elements into a Map by applying a classifier function, e.g., grouping employees by department."}
{"id":168,"question":"What is the default method in interfaces?","options":{"a":"A method with no return type","b":"A method with default keyword providing body in interface","c":"A method that must be overridden","d":"A static method in interface"},"answer":"b","explanation":"Default methods in interfaces use the default keyword and provide implementation, enabling backward compatibility."}
{"id":169,"question":"What are sealed classes in Java?","options":{"a":"Classes that cannot be extended","b":"Classes that restrict which classes can extend them","c":"Classes marked with final","d":"Classes used only in records"},"answer":"b","explanation":"Sealed classes (introduced in Java 17) restrict which classes or interfaces can extend or implement them using permits keyword."}
{"id":170,"question":"What is a record class in Java?","options":{"a":"A special class for logging","b":"A compact class for immutable data with automatic constructor, equals, hashCode, and toString","c":"A replacement for enums","d":"A database class"},"answer":"b","explanation":"Records are immutable data carriers introduced in Java 14+, auto-generating constructor, equals, hashCode, and toString."}
{"id":171,"question":"Difference between checked and unchecked exceptions.","options":{"a":"Checked are subclasses of RuntimeException, unchecked are not","b":"Checked must be declared/handled, unchecked do not require it","c":"Unchecked must be declared, checked do not","d":"Both are same"},"answer":"b","explanation":"Checked exceptions must be declared or handled; unchecked exceptions (RuntimeException) are not required to be declared."}
{"id":172,"question":"How is custom exception handling used in real-world applications?","options":{"a":"By ignoring exceptions","b":"By creating user-defined exception classes extending Exception or RuntimeException","c":"By always using try-finally only","d":"By suppressing errors"},"answer":"b","explanation":"Custom exceptions are created by extending Exception/RuntimeException to represent domain-specific errors for better clarity and handling."}
{"id":173,"question":"What is the diamond problem in Java?","options":{"a":"Ambiguity caused by multiple inheritance of classes","b":"Confusion in enum usage","c":"Hash collision issue","d":"Reflection ambiguity"},"answer":"a","explanation":"Diamond problem arises with multiple inheritance, but Java avoids it with single class inheritance and resolves with interface default methods."}
{"id":174,"question":"How does autoboxing/unboxing work?","options":{"a":"Converts primitives to wrappers and vice versa automatically","b":"Converts Strings to primitives","c":"Manual casting of objects","d":"Reflection-based type conversion"},"answer":"a","explanation":"Autoboxing automatically converts primitives to wrapper objects, and unboxing converts wrappers back to primitives."}
{"id":175,"question":"Explain Enum in Java.","options":{"a":"A collection class","b":"A special type for fixed constants with type safety","c":"A wrapper class","d":"A primitive type"},"answer":"b","explanation":"Enums represent fixed sets of constants with type safety and can include fields, methods, and constructors."}
{"id":176,"question":"When to use TreeMap vs HashMap?","options":{"a":"TreeMap is unordered, HashMap is ordered","b":"TreeMap maintains sorted keys, HashMap provides constant-time lookup","c":"Both are identical","d":"HashMap is thread-safe, TreeMap is not"},"answer":"b","explanation":"TreeMap maintains natural or custom ordering of keys (O(log n)), while HashMap gives constant-time lookup (O(1))."}
{"id":177,"question":"Why should hashCode() be consistent with equals()?","options":{"a":"To allow garbage collection","b":"To ensure objects behave correctly in hash-based collections","c":"To improve JVM performance","d":"To support reflection"},"answer":"b","explanation":"If equals() returns true, hashCode() must return same value; otherwise collections like HashMap/HashSet will misbehave."}
{"id":178,"question":"How to make an object immutable?","options":{"a":"By marking class abstract","b":"By making fields final, private, no setters, and defensive copying","c":"By synchronizing methods","d":"By using static fields"},"answer":"b","explanation":"Immutable objects have final private fields, no setters, constructors set values, and defensive copies for mutable fields."}
{"id":179,"question":"What is the use of transient keyword?","options":{"a":"Marks a variable as constant","b":"Prevents a field from being serialized","c":"Prevents inheritance","d":"Used only in enums"},"answer":"b","explanation":"The transient keyword prevents a field from being serialized, useful for sensitive or derived data."}
{"id":180,"question":"What is reflection in Java?","options":{"a":"Ability to create threads","b":"Ability to inspect and manipulate classes, methods, fields at runtime","c":"Garbage Collection process","d":"Default method in interfaces"},"answer":"b","explanation":"Reflection allows inspection and modification of class members at runtime using java.lang.reflect API."}
{"id":181,"question":"What is the difference between static and instance initialization block?","options":{"a":"Static runs once per class load, instance runs per object creation","b":"Both run per object creation","c":"Static runs per object, instance runs once per class","d":"No difference"},"answer":"a","explanation":"Static initialization block runs once when class is loaded; instance initialization block runs every time an object is created."}
{"id":182,"question":"Difference between shallow copy and deep copy.","options":{"a":"Shallow copies references, deep copies actual objects","b":"Shallow copy clones everything deeply","c":"Deep copy is faster","d":"Both are identical"},"answer":"a","explanation":"Shallow copy copies object references without new objects, while deep copy creates independent copies of nested objects."}
{"id":183,"question":"What is the use of System.identityHashCode()?","options":{"a":"Returns JVM memory address","b":"Returns default hash code regardless of overridden hashCode()","c":"Generates unique id for every object","d":"Stores hash in cache"},"answer":"b","explanation":"System.identityHashCode() returns the default hash code of an object even if its hashCode() is overridden."}
{"id":184,"question":"Explain CompletableFuture with example.","options":{"a":"Used for handling IO only","b":"Supports async programming with callbacks and chaining","c":"A replacement for ExecutorService","d":"A type of Stream"},"answer":"b","explanation":"CompletableFuture allows async tasks with methods like thenApply, thenRun, and can combine multiple futures."}
{"id":185,"question":"How do you implement a singleton pattern?","options":{"a":"By using abstract classes","b":"By making constructor private and providing static getInstance()","c":"By using final keyword","d":"By using multiple constructors"},"answer":"b","explanation":"Singleton ensures one instance by making constructor private and exposing a static method to get the instance."}
{"id":186,"question":"What are some ways to break a singleton?","options":{"a":"Using reflection, cloning, or serialization","b":"By using multiple threads","c":"By using default methods","d":"By using abstract classes"},"answer":"a","explanation":"Singletons can be broken by reflection, cloning, or serialization unless additional safeguards are applied."}
{"id":187,"question":"What is double-checked locking?","options":{"a":"A thread pool technique","b":"A concurrency pattern for lazy initialization with minimal locking","c":"A method of exception handling","d":"A GC optimization"},"answer":"b","explanation":"Double-checked locking reduces overhead by checking instance twice—once without locking and again inside synchronized block."}
{"id":188,"question":"What are phantom references?","options":{"a":"References that prevent GC","b":"References that are enqueued after object finalization","c":"References that act like weak references","d":"References to static fields"},"answer":"b","explanation":"PhantomReference objects are enqueued after the referent is finalized but before memory is reclaimed."}
{"id":189,"question":"Why is clone() considered bad practice?","options":{"a":"It is slow and doesn’t work for primitives","b":"It causes shallow copies, breaks encapsulation, and is error-prone","c":"It cannot be overridden","d":"It always throws exceptions"},"answer":"b","explanation":"clone() is discouraged because it causes shallow copies, violates encapsulation, and is complex to implement correctly."}
{"id":190,"question":"How would you design your own custom collection?","options":{"a":"By extending Collection or Map interfaces and implementing required methods","b":"By using only arrays","c":"By overriding hashCode","d":"By extending Object"},"answer":"a","explanation":"Custom collections can be built by implementing Collection/Map interfaces and defining behavior for required methods."}
{"id":191,"question":"Explain method overloading vs overriding.","options":{"a":"Overloading changes method behavior in subclass, overriding changes parameters","b":"Overloading is compile-time polymorphism, overriding is runtime polymorphism","c":"Both are identical","d":"Overriding is compile-time only"},"answer":"b","explanation":"Overloading defines multiple methods with same name but different signatures; overriding redefines method behavior in subclass."}
{"id":192,"question":"Explain covariant return types.","options":{"a":"Return type in overriding method can be a subclass of original return type","b":"Return type must always match exactly","c":"Return type must be Object","d":"Return type must be primitive"},"answer":"a","explanation":"Covariant return types allow overriding methods to return a more specific type than the method they override."}
{"id":193,"question":"How does Java handle pass-by-value or reference?","options":{"a":"Java is pass-by-reference","b":"Java is pass-by-value, but object references are passed by value","c":"Java uses both pass-by-value and reference","d":"Java is pass-by-pointer"},"answer":"b","explanation":"Java is strictly pass-by-value. For objects, the reference is passed by value, so changes to the object are reflected, but reassignments don’t affect the original reference."}
{"id":194,"question":"Can we override private/static/final methods?","options":{"a":"Yes, all can be overridden","b":"Private and static cannot be overridden, final methods cannot be overridden","c":"Static methods can be overridden","d":"Private methods can be overridden"},"answer":"b","explanation":"Private methods are not inherited, static methods are hidden not overridden, and final methods cannot be overridden."}
{"id":195,"question":"When would you use an abstract class over interface?","options":{"a":"When you want multiple inheritance","b":"When you need shared code with state and partial implementation","c":"When you need constants only","d":"When you need runtime polymorphism only"},"answer":"b","explanation":"Abstract classes allow fields, constructors, and partial implementations, making them useful when shared state or behavior is needed."}
{"id":196,"question":"What is java.lang.instrument used for?","options":{"a":"For database connections","b":"For bytecode instrumentation and profiling agents","c":"For GUI development","d":"For networking"},"answer":"b","explanation":"The java.lang.instrument package provides services that allow Java agents to instrument program bytecode at runtime."}
{"id":197,"question":"What is Metaspace in Java?","options":{"a":"Heap memory for objects","b":"Non-heap memory for class metadata introduced in Java 8","c":"Thread stack memory","d":"Off-heap storage for arrays"},"answer":"b","explanation":"Metaspace is the memory region in native memory where JVM stores class metadata, replacing PermGen from Java 8 onward."}
{"id":198,"question":"How to detect memory leaks in Java?","options":{"a":"By using GC logs and profiling tools like VisualVM, JConsole, or JProfiler","b":"By running System.gc()","c":"By monitoring stack memory","d":"By disabling threads"},"answer":"a","explanation":"Memory leaks can be detected using profiling tools, heap dumps, and analyzing GC logs."}
{"id":199,"question":"What is ClassLoader? Types of class loaders?","options":{"a":"Loads classes into memory; types include Bootstrap, Extension, Application, and custom loaders","b":"Handles garbage collection","c":"Creates threads","d":"Compiles Java code"},"answer":"a","explanation":"ClassLoader loads Java classes into memory; main types include Bootstrap, Extension, Application, and user-defined loaders."}
{"id":200,"question":"What is JIT compiler?","options":{"a":"Interpreter for Java","b":"Just-In-Time compiler that converts bytecode to native code at runtime","c":"Compiler for native libraries","d":"Garbage collector"},"answer":"b","explanation":"JIT compiler improves performance by compiling bytecode into native machine code during runtime execution."}
{"id":201,"question":"How do annotations work internally?","options":{"a":"Through reflection and bytecode processing","b":"By adding new keywords","c":"By changing JVM settings","d":"By creating subclasses automatically"},"answer":"a","explanation":"Annotations are metadata processed at compile time or runtime using reflection and annotation processors."}
{"id":202,"question":"How to create custom annotations?","options":{"a":"By extending Annotation class","b":"By using @interface with retention and target policies","c":"By creating abstract classes","d":"By subclassing Object"},"answer":"b","explanation":"Custom annotations are created with @interface and meta-annotations like @Retention and @Target."}
{"id":203,"question":"What is annotation processing in Java?","options":{"a":"Using annotations for reflection only","b":"Tools/APIs process annotations at compile-time to generate code or configurations","c":"Using annotations for debugging","d":"Annotations always change bytecode"},"answer":"b","explanation":"Annotation processing uses tools like apt or javax.annotation.processing API to process annotations at compile-time."}
{"id":204,"question":"What are lambdas and how do they work internally?","options":{"a":"They are anonymous classes compiled as inner classes","b":"They are syntactic sugar implemented using invokedynamic","c":"They are macros expanded at compile-time","d":"They are reflection-based"},"answer":"b","explanation":"Lambdas are implemented using invokedynamic and converted to functional interfaces at runtime."}
{"id":205,"question":"Explain Type Erasure in Generics.","options":{"a":"Generics are replaced with Object at runtime, removing type info","b":"Generics are stored as metadata","c":"Generics create new classes per type","d":"Generics exist only in JVM"},"answer":"a","explanation":"Type Erasure removes generic type info at runtime, replacing with Object or bounded type."}
{"id":206,"question":"How are Generics implemented internally?","options":{"a":"Using templates like C++","b":"Using type erasure with casting and bridge methods","c":"By creating separate bytecode per type","d":"By JVM native instructions"},"answer":"b","explanation":"Generics are implemented via type erasure, where type parameters are erased and casts/bridge methods maintain type safety."}
{"id":207,"question":"Explain bounded vs unbounded wildcards.","options":{"a":"Bounded uses ? extends/super, unbounded is just ?","b":"Bounded is faster","c":"Unbounded allows only numbers","d":"Both are the same"},"answer":"a","explanation":"Bounded wildcards (? extends T / ? super T) restrict types; unbounded wildcard (?) accepts any type."}
{"id":208,"question":"What is raw type in Java?","options":{"a":"A generic type used without specifying type parameters","b":"A primitive type","c":"A type erased class","d":"A default type in JVM"},"answer":"a","explanation":"A raw type is a generic class used without type parameters, e.g., List instead of List<String>."}
{"id":209,"question":"How would you make a list thread-safe?","options":{"a":"By using Collections.synchronizedList() or CopyOnWriteArrayList","b":"By using LinkedList","c":"By using volatile variables","d":"By disabling threads"},"answer":"a","explanation":"Thread-safe lists can be created using Collections.synchronizedList() or concurrent classes like CopyOnWriteArrayList."}
{"id":210,"question":"How to avoid deadlock in concurrent programming?","options":{"a":"Avoid nested locks, use lock ordering, timeouts, and tryLock","b":"Always use synchronized","c":"Use more threads","d":"Ignore concurrency"},"answer":"a","explanation":"Deadlock can be prevented by consistent lock ordering, avoiding nested locks, and using timeouts or tryLock."}
{"id":211,"question":"Difference between Spring and Spring Boot.","options":{"a":"Spring Boot is a subset of Spring with auto-configuration and starter dependencies","b":"Spring is lighter than Spring Boot","c":"Spring Boot replaces Spring","d":"Spring Boot is unrelated to Spring"},"answer":"a","explanation":"Spring Boot builds on Spring, adding auto-configuration, embedded servers, and starters for rapid development."}
{"id":212,"question":"What is dependency injection and how is it implemented in Spring?","options":{"a":"Creating dependencies inside class","b":"Providing dependencies externally via constructors, setters, or annotations","c":"Using static variables","d":"Using inheritance"},"answer":"b","explanation":"Dependency Injection in Spring provides objects via constructors, setters, or @Autowired, instead of creating them directly."}
{"id":213,"question":"Difference between @Component, @Service, @Repository, and @Controller.","options":{"a":"All are identical","b":"They are stereotypes with semantic roles: generic bean, service, DAO, and web controller","c":"Only @Controller creates beans","d":"@Repository is for Spring Boot only"},"answer":"b","explanation":"All create Spring beans, but with semantic meaning: @Component (generic), @Service (business logic), @Repository (DAO with exception translation), @Controller (web MVC)." }
{"id":214,"question":"What is the role of @Autowired and how does it work?","options":{"a":"Marks beans for logging","b":"Injects dependencies by type from the Spring context","c":"Creates new objects","d":"Runs background threads"},"answer":"b","explanation":"@Autowired tells Spring to resolve and inject a matching bean from the context by type (and optionally qualifier)." }
{"id":215,"question":"How does Spring Boot auto-configuration work?","options":{"a":"By using @EnableAutoConfiguration and conditionally configuring beans based on classpath and properties","b":"By manually creating beans","c":"By disabling configuration","d":"By creating only default beans"},"answer":"a","explanation":"Spring Boot auto-configuration checks the classpath and conditions, automatically providing beans using @EnableAutoConfiguration." }
{"id":216,"question":"What are the starter dependencies in Spring Boot?","options":{"a":"Pre-configured Maven/Gradle dependencies for common use cases","b":"Custom JDK classes","c":"Only database drivers","d":"Only web dependencies"},"answer":"a","explanation":"Starter dependencies are pre-packaged dependencies like spring-boot-starter-web, reducing boilerplate setup."}
{"id":217,"question":"What is @SpringBootApplication composed of?","options":{"a":"@Configuration + @EnableAutoConfiguration + @ComponentScan","b":"@Controller + @Service + @Repository","c":"@Bean + @Import + @Qualifier","d":"@Autowired + @Qualifier"},"answer":"a","explanation":"@SpringBootApplication is a meta-annotation combining @Configuration, @EnableAutoConfiguration, and @ComponentScan."}
{"id":218,"question":"How does component scanning work in Spring Boot?","options":{"a":"Scans only JDK packages","b":"Scans packages from the main application class downward to register beans","c":"Scans only database packages","d":"Scans all classpath automatically"},"answer":"b","explanation":"Spring Boot scans packages starting from the package of the main class to register beans annotated with stereotypes."}
{"id":219,"question":"How do profiles work in Spring Boot?","options":{"a":"Profiles allow defining different beans and configs for environments like dev, test, prod","b":"Profiles are for user authentication","c":"Profiles replace dependencies","d":"Profiles manage only logging"},"answer":"a","explanation":"Profiles allow beans and configurations to be conditionally loaded based on active profile (dev, test, prod)."}
{"id":220,"question":"What are beans in Spring? Lifecycle?","options":{"a":"Objects managed by Spring IoC container; lifecycle includes instantiation, dependency injection, initialization, and destruction","b":"Any object created in Java","c":"Only entities in DB","d":"Only controllers"},"answer":"a","explanation":"Beans are managed objects in Spring context; lifecycle steps: instantiation → dependency injection → initialization (@PostConstruct/init) → destruction (@PreDestroy/destroy)." }
