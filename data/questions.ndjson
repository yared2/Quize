{"id":101,"question":"What does the Java Memory Model guarantee with 'volatile' writes?","options":{"a":"Atomicity for all operations on the variable including ++","b":"Visibility and ordering (happens-before) from writer to subsequent readers","c":"Mutual exclusion for the variable","d":"Prevents false sharing"},"answer":"b","explanation":"volatile guarantees visibility + ordering (write → read happens-before); it does not provide atomic compound ops or mutual exclusion."}
{"id":102,"question":"Which statement about 'synchronized' is TRUE?","options":{"a":"It only provides visibility, not mutual exclusion","b":"It establishes happens-before from monitor exit to subsequent monitor enter on the same monitor","c":"It is faster than ReentrantLock in all cases","d":"It supports tryLock() with timeout"},"answer":"b","explanation":"Exiting a monitor happens-before a subsequent enter on the same monitor. It provides mutual exclusion; ReentrantLock adds features like tryLock()."}
{"id":103,"question":"Which operation on ConcurrentHashMap is atomic w.r.t. mapping presence?","options":{"a":"getOrDefault","b":"computeIfAbsent","c":"replaceAll","d":"forEach"},"answer":"b","explanation":"computeIfAbsent atomically checks presence and inserts the computed value for a key if absent."}
{"id":104,"question":"In Streams, which is a terminal operation?","options":{"a":"map","b":"peek","c":"collect","d":"filter"},"answer":"c","explanation":"collect is terminal; map, peek, filter are intermediate."}
{"id":105,"question":"Parallel streams: which is a common pitfall?","options":{"a":"Using stateless, associative reductions","b":"Using thread-safe collectors like toConcurrentMap","c":"Using non-associative accumulation (e.g., floating-point order sensitive)","d":"Using unordered sources"},"answer":"c","explanation":"Parallel reductions require associativity; non-associative ops can yield inconsistent results."}
{"id":106,"question":"CompletableFuture: which combines two independent futures and returns when BOTH complete?","options":{"a":"anyOf","b":"allOf","c":"applyToEither","d":"acceptEither"},"answer":"b","explanation":"allOf waits for all futures to complete; anyOf waits for any one."}
{"id":107,"question":"Which is TRUE about ForkJoinPool?","options":{"a":"Best for blocking I/O tasks","b":"Uses work-stealing among worker queues","c":"Requires explicit Thread creation","d":"Cannot run recursive tasks"},"answer":"b","explanation":"ForkJoinPool uses work-stealing; it’s designed for compute-bound, fine-grained tasks."}
{"id":108,"question":"Which GC is designed for low-pause times with region-based heap and is default in modern JDKs?","options":{"a":"Serial GC","b":"CMS","c":"G1 GC","d":"Epsilon"},"answer":"c","explanation":"G1 is region-based and default in recent JDK LTS versions (e.g., 17, 21), targeting predictable pauses."}
{"id":109,"question":"Which GC aims for ultra-low pauses with concurrent compaction and barrier-heavy design?","options":{"a":"Parallel GC","b":"ZGC","c":"Serial GC","d":"Shenandoah is the same as ZGC implementation"},"answer":"b","explanation":"ZGC is a concurrent, regioned, colored-pointers GC targeting very low pauses; Shenandoah is similar in goal but distinct."}
{"id":110,"question":"What does 'escape analysis' enable in HotSpot JIT?","options":{"a":"Turning objects into primitives","b":"Stack allocation and scalar replacement of non-escaping objects","c":"Ahead-of-time compilation only","d":"Disabling bounds checks"},"answer":"b","explanation":"If an object doesn’t escape a method/thread, JIT can allocate on stack or eliminate it via scalar replacement."}
{"id":111,"question":"Which is TRUE about the 'happens-before' relation?","options":{"a":"It is equivalent to wall-clock time","b":"Program order within a single thread contributes to happens-before","c":"It only arises from locks, not volatiles","d":"It guarantees fairness of scheduling"},"answer":"b","explanation":"Within a single thread, actions are ordered; synchronization constructs (locks, volatiles) also create happens-before edges."}
{"id":112,"question":"Which class provides lock downgrading (write→read) semantics?","options":{"a":"ReentrantLock","b":"Semaphore","c":"ReentrantReadWriteLock","d":"StampedLock only"},"answer":"c","explanation":"ReentrantReadWriteLock allows acquiring write then downgrading to read while holding locks properly."}
{"id":113,"question":"What’s a safe pattern to avoid ThreadLocal memory leaks in pools?","options":{"a":"Never remove values","b":"Use static ThreadLocal","c":"Call remove() in finally after use","d":"Use WeakReference yourself"},"answer":"c","explanation":"In pooled threads, always remove ThreadLocal values in finally-blocks to avoid retention."}
{"id":114,"question":"Which Map removes entries when keys are no longer strongly referenced?","options":{"a":"LinkedHashMap with accessOrder=true","b":"WeakHashMap","c":"IdentityHashMap","d":"ConcurrentSkipListMap"},"answer":"b","explanation":"WeakHashMap uses weak keys; entries are cleared when keys are GC-eligible."}
{"id":115,"question":"LinkedHashMap can be used to build an LRU cache by overriding which method?","options":{"a":"hashCode","b":"remove","c":"removeEldestEntry","d":"putIfAbsent"},"answer":"c","explanation":"Override removeEldestEntry and set accessOrder=true to evict least recently used entries."}
{"id":116,"question":"Which statement about 'record' in Java is TRUE?","options":{"a":"Records are mutable by default","b":"Records implicitly extend java.lang.Record and are final","c":"Records cannot define methods","d":"Records cannot implement interfaces"},"answer":"b","explanation":"Records are final, implicitly extend Record, and can define methods and implement interfaces; components are final."}
{"id":117,"question":"Sealed classes: which is valid?","options":{"a":"A sealed class must list permitted subclasses","b":"A sealed class cannot have final subclasses","c":"Permits must be at runtime only","d":"Sealed classes replace access modifiers"},"answer":"a","explanation":"Sealed classes enumerate permitted subclasses; subclasses must be sealed, non-sealed, or final."}
{"id":118,"question":"Pattern matching for 'instanceof' mainly helps with:","options":{"a":"Eliminating switch","b":"Reducing casts after the check","c":"Overloading resolution","d":"Operator overloading"},"answer":"b","explanation":"Pattern matching binds a variable when the instanceof test succeeds, avoiding explicit casts."}
{"id":119,"question":"JPMS modules vs classpath: what’s a key advantage of modules?","options":{"a":"Faster I/O","b":"Stronger encapsulation and reliable configuration","c":"Automatic serialization","d":"Guaranteed ABI stability across JDKs"},"answer":"b","explanation":"Modules provide explicit dependencies/exports and strong encapsulation beyond classpath rules."}
{"id":120,"question":"Which NIO feature supports asynchronous file I/O on supporting platforms?","options":{"a":"FileInputStream","b":"AsynchronousFileChannel","c":"BufferedReader","d":"RandomAccessFile only"},"answer":"b","explanation":"AsynchronousFileChannel provides async I/O operations in NIO.2."}
{"id":121,"question":"Which statement about Optional is BEST practice?","options":{"a":"Use Optional for fields to model absence","b":"Return Optional in public APIs, don’t use it for fields","c":"Serialize Optionals","d":"Use Optional for parameters"},"answer":"b","explanation":"Optional is for return types to signal possible absence; avoid fields/params for performance/clarity."}
{"id":122,"question":"Which is TRUE about virtual threads (Project Loom)?","options":{"a":"They are OS threads","b":"They are user-mode threads scheduled by the JVM, enabling massive concurrency","c":"They require synchronized for correctness","d":"They replace ExecutorService"},"answer":"b","explanation":"Virtual threads are lightweight, JVM-scheduled (user-mode) threads; they work with existing executors/APIs."}
{"id":123,"question":"CompletableFuture: which composes dependent async tasks sequentially?","options":{"a":"thenApply","b":"thenCompose","c":"thenAcceptBoth","d":"runAfterBoth"},"answer":"b","explanation":"thenCompose flattens and chains dependent futures (async → async)."}
{"id":124,"question":"Which annotation retention allows reflection at runtime?","options":{"a":"SOURCE","b":"CLASS","c":"RUNTIME","d":"BINARY"},"answer":"c","explanation":"RUNTIME retention keeps annotations available to reflection during execution."}
{"id":125,"question":"Which is TRUE about equals & hashCode?","options":{"a":"Only equals must be consistent with hashCode","b":"If equals is overridden, hashCode must usually be overridden","c":"hashCode may change within a HashSet safely","d":"Using mutable fields in hashCode is harmless"},"answer":"b","explanation":"Objects equal to each other must produce equal hash codes; mutability in keys can break hashed collections."}
{"id":126,"question":"What does VarHandle provide over sun.misc.Unsafe?","options":{"a":"Private, unsupported API","b":"A standardized, safe, reflective access to variables with memory-order ops","c":"No atomic operations","d":"Deprecated since Java 9"},"answer":"b","explanation":"VarHandle is the standard supported API for low-level atomic/memory-ordered operations."}
{"id":127,"question":"Which Collector is safe and efficient for parallel streams to build a Map?","options":{"a":"Collectors.toMap (with default merger)","b":"Collectors.toConcurrentMap (with merger)","c":"Collectors.groupingBy without supplier","d":"Collectors.toUnmodifiableMap"},"answer":"b","explanation":"toConcurrentMap with a merge function is designed for concurrent accumulation."}
{"id":128,"question":"Which tool/flag pair enables class data sharing to speed startup?","options":{"a":"-Xshare:off with CDS archive","b":"CDS/AppCDS with -Xshare:on","c":"-verbose:class only","d":"JFR automatically does this"},"answer":"b","explanation":"CDS/AppCDS share class metadata across JVMs using archives; enable with -Xshare:on."}
{"id":129,"question":"Which synchronization primitive best coordinates a variable number of phased tasks?","options":{"a":"CountDownLatch","b":"CyclicBarrier only","c":"Phaser","d":"Semaphore"},"answer":"c","explanation":"Phaser supports dynamic registration and multiple phases; more flexible than CountDownLatch/Barrier."}
{"id":130,"question":"StampedLock optimistic read: main caveat?","options":{"a":"It blocks writers","b":"Must validate the stamp before trusting the read","c":"It upgrades automatically to write lock","d":"It replaces volatile"},"answer":"b","explanation":"Optimistic reads must call validate(stamp) to ensure no write occurred; otherwise retry."}
===========
{"id":201,"question":"What is the main purpose of an API Gateway in microservices?","options":{"a":"Database normalization","b":"Centralized routing, security, and aggregation","c":"Managing CI/CD pipelines","d":"Scaling the database"},"answer":"b","explanation":"An API Gateway acts as a single entry point to route requests, handle authentication, rate limiting, and sometimes aggregate responses from multiple services."}
{"id":202,"question":"Why do microservices often use asynchronous communication?","options":{"a":"It ensures immediate consistency","b":"It reduces coupling and improves scalability","c":"It eliminates the need for APIs","d":"It guarantees no data loss"},"answer":"b","explanation":"Asynchronous communication (via Kafka, RabbitMQ, etc.) allows services to remain loosely coupled and scale independently without blocking requests."}
{"id":203,"question":"In microservices, what problem does service discovery solve?","options":{"a":"Caching frequently used data","b":"Finding network locations of running service instances","c":"Encrypting service traffic","d":"Deploying containers automatically"},"answer":"b","explanation":"Service discovery dynamically tracks and provides endpoints for service instances, as IP/port addresses may change frequently in cloud or containerized environments."}
{"id":204,"question":"Which pattern is used to handle failures gracefully in microservices?","options":{"a":"Singleton","b":"Circuit Breaker","c":"Observer","d":"Decorator"},"answer":"b","explanation":"The Circuit Breaker pattern prevents cascading failures by stopping requests to a failing service and allowing it to recover."}
{"id":205,"question":"Why is database-per-service recommended in microservices?","options":{"a":"It ensures every service has the same schema","b":"It enforces loose coupling and independent scaling","c":"It makes joins easier across services","d":"It allows all services to share a single cache"},"answer":"b","explanation":"A database-per-service ensures data ownership, independence, and prevents tight coupling between services."}
{"id":206,"question":"What’s the main drawback of distributed transactions in microservices?","options":{"a":"They are too fast","b":"They increase system coupling and complexity","c":"They eliminate consistency issues","d":"They prevent scaling"},"answer":"b","explanation":"Distributed transactions (like 2PC) add latency, complexity, and tight coupling, which goes against microservice principles."}
{"id":207,"question":"Which principle does the Saga pattern enforce in microservices?","options":{"a":"Immediate consistency","b":"Eventual consistency via local transactions","c":"Centralized transaction manager","d":"Database-per-cluster"},"answer":"b","explanation":"Saga breaks large distributed transactions into smaller local transactions coordinated via events, ensuring eventual consistency."}
{"id":208,"question":"What role does observability play in microservices?","options":{"a":"It manages scaling policies","b":"It provides visibility with logs, metrics, and traces","c":"It stores application secrets","d":"It ensures only stateless services run"},"answer":"b","explanation":"Observability (via tools like ELK, Prometheus, Grafana, Zipkin) helps monitor system health with logs, metrics, and distributed traces."}
{"id":209,"question":"Why is containerization (e.g., Docker) commonly used for microservices?","options":{"a":"It enforces strong typing in services","b":"It ensures consistent environments and portability","c":"It eliminates the need for APIs","d":"It avoids CI/CD pipelines"},"answer":"b","explanation":"Containers package microservices with dependencies, ensuring consistency across development, test, and production environments."}
{"id":210,"question":"What is the main challenge with inter-service communication in microservices?","options":{"a":"It makes debugging easier","b":"It introduces network latency and reliability concerns","c":"It prevents scaling","d":"It simplifies data consistency"},"answer":"b","explanation":"Since microservices communicate over the network, latency, retries, and reliability must be carefully handled with patterns like retries, timeouts, and circuit breakers."}
